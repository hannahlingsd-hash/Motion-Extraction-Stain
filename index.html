
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Wind-on-Wall — Ghosts + Stain (hi-res)</title>

<style>
  :root{
    --bg:#fff; --fg:#000; --mut:#333; --line:#000;
    --colL:180px;                 /* left column width */
    --colR:280px;                 /* right column width */
    --track-fill:#111;            /* slider left/value (very dark grey) */
    --track-bg:#cfcfcf;           /* slider remainder (light grey) */
    --topPad:8px;                 /* top padding for L/R columns */
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font:13px/1.45 Arial, Helvetica, sans-serif}
  *{box-sizing:border-box;border-radius:0}
  button,input,select,label{font:inherit;color:var(--fg);background:#fff;margin:0}

  /* Layout */
  .wrap{
    display:grid;
    grid-template-columns: var(--colL) 1fr var(--colR);
    gap:16px; height:100vh; padding:12px;
  }
  aside.controls{padding-top:var(--topPad); overflow:hidden;}
  aside.panel{padding-top:var(--topPad)}
  main{position:relative;display:flex;align-items:center;justify-content:center}

  /* Stage (no borders/hairlines) */
  .stage{position:relative;width:min(90%,1280px);aspect-ratio:16/9;margin:auto}
  canvas{position:absolute;inset:0;width:100%;height:100%;object-fit:contain;background:#000;border:0;outline:0;box-shadow:none}

  /* Right column rhythm */
  .group{font-weight:700;margin:18px 0 6px}
  .panel .group:first-of-type{margin-top:6px}
  .row{display:grid;align-items:center;gap:8px;margin:6px 0;grid-template-columns:1fr minmax(120px,1.6fr) 44px}
  .row.compact{grid-template-columns:1fr auto 44px}
  .row > span{text-align:right;color:#000}
  .row label{color:var(--fg)}

  /* LEFT column – tight & consistent */
  .leftRows{display:grid;row-gap:6px}
  aside.controls .group{margin:12px 0 4px}
  aside.controls .row{margin:0}
  .btnRow{display:flex;gap:8px;flex-wrap:wrap;margin:0}
  .inlineRow{display:flex;align-items:center;gap:8px;margin:0}

  /* Buttons */
  .btn{appearance:none;background:#fff;color:#000;border:1px solid var(--line);padding:6px 10px;cursor:pointer}
  .btn.secondary{background:#fff}
  .btn:disabled{opacity:.5;cursor:not-allowed}

  /* Sliders (dark left, light right) */
  input[type="range"]{appearance:none;height:2px;outline:none;background:linear-gradient(to right,var(--track-fill) 0 var(--p,0%),var(--track-bg) var(--p,0%) 100%)}
  input[type="range"]::-webkit-slider-thumb{appearance:none;width:10px;height:10px;background:#000;border:1px solid #000}
  input[type="range"]::-moz-range-thumb{width:10px;height:10px;background:#000;border:1px solid #000}
  input[type="range"]::-moz-range-track{height:2px;background:var(--track-bg)}
  input[type="range"]::-moz-range-progress{height:2px;background:var(--track-fill)}

  input[type="color"]{width:32px;height:22px;border:1px solid #000;background:#fff;padding:0}

  /* Hide debug HUD overlay */
  .hud{display:none!important}
  .rec{position:absolute;top:10px;right:10px;background:rgba(0,0,0,.6);color:#fff;padding:6px 10px;display:flex;align-items:center;gap:8px}
  .dot{width:8px;height:8px;background:#ff5b5b;border-radius:50%;box-shadow:0 0 8px #ff5b5b}
  .nosrc{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;color:#888;font:12px ui-monospace;pointer-events:none}
  .fab{display:none}
  .small{font-size:12px;color:#333}
</style>
</head>

<body>
<div class="wrap">
  <!-- LEFT -->
  <aside class="controls">
    <div class="leftRows">
      <div class="btnRow">
        <input id="file" type="file" accept="video/*">
        <button id="webcam" class="btn">Webcam</button>
      </div>
      <div class="btnRow">
        <button id="play" class="btn secondary">Play/Pause</button>
        <button id="replay" class="btn secondary">Replay</button>
      </div>

      <div class="group">Export</div>

      <!-- Start/Stop stacked -->
      <div class="btnRow"><button id="recStart" class="btn">Start Recording</button></div>
      <div class="btnRow"><button id="recStop" class="btn" disabled>Stop &amp; Save</button></div>

      <div class="btnRow"><button id="shot" class="btn secondary">Export PNG</button></div>
      <div class="btnRow"><button id="exportOne" class="btn">Export 1:1 (source)</button></div>

      <div class="inlineRow">
        <label for="matchPreview">Match preview</label>
        <input id="matchPreview" type="checkbox" checked>
      </div>

      <div class="small" id="supportNote"></div>
      <div class="small" id="dbg">buffer: 0 | fps —</div>
    </div>
  </aside>

  <!-- CENTER -->
  <main>
    <div class="stage">
      <canvas id="stain"></canvas>
      <canvas id="ghost"></canvas>
      <canvas id="final"></canvas>
      <div id="hud" class="hud"></div>
      <div id="recHUD" class="rec" style="display:none;"><span class="dot"></span><span id="recTime">REC 00:00</span></div>
      <div id="nosrc" class="nosrc" style="display:none;">load a clip or use the webcam</div>
      <button id="replayFloat" class="fab" title="Replay (R)">↺</button>
    </div>
  </main>

  <!-- RIGHT -->
  <aside class="panel">
    <div class="group">Temporal window</div>
    <div class="row"><label>Δt (seconds)</label><input id="dt" type="range" min="2" max="10" step="0.5" value="6"><span id="dtV">6.0</span></div>
    <div class="row"><label>Diff threshold</label><input id="thr" type="range" min="4" max="60" value="26"><span id="thrV">26</span></div>
    <div class="row"><label>Grey level</label><input id="grey" type="range" min="60" max="200" value="200"><span id="greyV">200</span></div>
    <div class="row"><label>Pre-blur (px)</label><input id="preblur" type="range" min="0" max="3" value="0"><span id="preblurV">0</span></div>

    <div class="group">Ghosts</div>
    <div class="row"><label>Ghost opacity</label><input id="gAlpha" type="range" min="0" max="1" step="0.05" value="0.7"><span id="gAlphaV">0.70</span></div>
    <div class="row">
      <label>Blend mode</label>
      <select id="gBlend">
        <option value="normal" selected>Normal</option>
        <option value="screen">Screen</option>
        <option value="lighter">Lighter (Add)</option>
        <option value="multiply">Multiply</option>
        <option value="difference">Difference</option>
      </select>
      <span></span>
    </div>
    <div class="row compact">
      <label>Ghost color</label>
      <input id="gUseColor" type="checkbox" checked style="display:none">
      <input id="gColor" type="color" value="#ffffff">
    </div>

    <div class="group">Stain</div>
    <div class="row compact"><label>Enable stain</label><input id="stainOn" type="checkbox" checked></div>
    <div class="row"><label>Decay</label><input id="decay" type="range" min="0.90" max="0.995" step="0.001" value="0.970"><span id="decayV">0.970</span></div>
    <div class="row"><label>Strength</label><input id="strength" type="range" min="0.1" max="1" step="0.05" value="0.50"><span id="strengthV">0.50</span></div>
    <div class="row"><label>Expand (px)</label><input id="expand" type="range" min="0" max="8" step="1" value="2"><span id="expandV">2</span></div>
    <div class="row compact"><label>Stain color</label><input id="sColor" type="color" value="#223b7a"></div>

    <div class="group">Recalls</div>
    <div class="row compact"><label>Enable recall</label><input id="recallOn" type="checkbox"></div>
    <div class="row"><label>Probability</label><input id="recallProb" type="range" min="0" max="1" step="0.01" value="0.20"><span id="recallProbV">0.20</span></div>
    <div class="row"><label>Capacity</label><input id="recallCap" type="range" min="0" max="120" step="5" value="40"><span id="recallCapV">40</span></div>
    <div class="row compact"><label>Recall color</label><input id="recallColor" type="color" value="#00e7ff"></div>
    <div class="row"><label>Linger (s)</label><input id="recallLinger" type="range" min="0.2" max="3" step="0.1" value="1.2"><span id="recallLingerV">1.2</span></div>
    <div class="row"><label>Span (s)</label><input id="recallSpan" type="range" min="0" max="3" step="0.1" value="0.8"><span id="recallSpanV">0.8</span></div>
    <div class="btnRow"><button id="recallNow" class="btn">Recall now</button></div>
  </aside>
</div>

<!-- ===== SCRIPT: functionality (Auto format) ===== -->
<script>
(function(){
  /* ---------- Elements ---------- */
  const can = { stain:stain, ghost:ghost, final:final };
  const sctx = can.stain.getContext('2d');
  const gctx = can.ghost.getContext('2d');
  const fctx = can.final.getContext('2d');

  const file = document.getElementById('file');
  const webcamBtn = document.getElementById('webcam');
  const playBtn = document.getElementById('play');
  const replayBtn = document.getElementById('replay');
  const replayFloat = document.getElementById('replayFloat');
  const recStartBtn = document.getElementById('recStart');
  const recStopBtn  = document.getElementById('recStop');
  const shotBtn = document.getElementById('shot');
  const exportOneBtn = document.getElementById('exportOne');
  const matchPreview = document.getElementById('matchPreview');
  const hud = document.getElementById('hud');
  const recHUD = document.getElementById('recHUD');
  const recTime = document.getElementById('recTime');
  const dbg = document.getElementById('dbg');
  const supportNote = document.getElementById('supportNote');
  const nosrc = document.getElementById('nosrc');

  const ids = ["dt","thr","grey","preblur","gAlpha","decay","strength","expand"];
  const el  = Object.fromEntries(ids.map(id=>[id, document.getElementById(id)]));
  const out = Object.fromEntries(ids.map(id=>[id+"V", document.getElementById(id+"V")]));
  const stainOn = document.getElementById('stainOn');
  const sColor  = document.getElementById('sColor');
  const gBlend  = document.getElementById('gBlend');
  const gUseColor = document.getElementById('gUseColor');
  const gColor    = document.getElementById('gColor');

  function sync(){
    out.dtV.textContent      = (+el.dt.value).toFixed(1);
    out.thrV.textContent     = el.thr.value;
    out.greyV.textContent    = el.grey.value;
    out.preblurV.textContent = el.preblur.value;
    out.gAlphaV.textContent  = (+el.gAlpha.value).toFixed(2);
    out.decayV.textContent   = (+el.decay.value).toFixed(3);
    out.strengthV.textContent= (+el.strength.value).toFixed(2);
    out.expandV.textContent  = el.expand.value;
  }
  [...ids.map(id=>el[id]), stainOn, sColor, gBlend, gUseColor, gColor].forEach(x=>x.addEventListener('input', sync));
  sync();

  /* ---------- Source ---------- */
  const vid = document.createElement('video');
  vid.crossOrigin = "anonymous";
  vid.playsInline = true; vid.muted = true; vid.loop = true; vid.preload = "auto";

  const qs = new URLSearchParams(location.search);
  const src = qs.get('src'); if(src){ vid.src = src; }

  let mediaStream = null;
  file.addEventListener('change', e=>{
    const f = e.target.files[0]; if(!f) return;
    stopWebcam(); resetState(); vid.src = URL.createObjectURL(f); vid.play();
  });
  playBtn.addEventListener('click', ()=> vid.paused ? vid.play() : vid.pause());
  webcamBtn.addEventListener('click', ()=> startWebcam().catch(e=>alert('Webcam failed: '+(e && e.message ? e.message : e))));

  async function startWebcam(){
    const secure = (location.protocol==='https:'||location.hostname==='localhost'||location.hostname==='127.0.0.1');
    if(!secure) throw new Error('Camera requires HTTPS or localhost.');
    if(!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia) throw new Error('getUserMedia is not available in this browser.');

    stopWebcam(); resetState();
    const tries=[{video:{facingMode:{ideal:'environment'},width:{ideal:1280},height:{ideal:720}},audio:false},{video:true,audio:false}];
    let errLast=null;
    for(const constraints of tries){ try{ mediaStream=await navigator.mediaDevices.getUserMedia(constraints); break; }catch(err){errLast=err;mediaStream=null;} }
    if(!mediaStream){
      if(errLast && (errLast.name==='NotAllowedError'||errLast.name==='SecurityError')) throw new Error('Camera permission blocked. Allow access in site settings.');
      if(errLast && errLast.name==='NotFoundError') throw new Error('No camera device found.');
      throw errLast || new Error('Unable to access camera.');
    }
    vid.srcObject = mediaStream;
    await new Promise(res=>{ if(vid.readyState>=1) return res(); vid.addEventListener('loadedmetadata',res,{once:true}); });
    try{ await vid.play(); }catch(_){ throw new Error('Autoplay failed. Click Play or allow autoplay.'); }
  }
  function stopWebcam(){ if(mediaStream){ try{mediaStream.getTracks().forEach(t=>t.stop());}catch(_){} mediaStream=null; } if(vid && vid.srcObject){ try{vid.srcObject=null;}catch(_){} } }

  /* ---------- Sizing ---------- */
  const proc = document.createElement('canvas'); const pctx = proc.getContext('2d',{willReadFrequently:true});
  const maskCanvas = document.createElement('canvas'); const maskCtx = maskCanvas.getContext('2d');
  const colCanvas = document.createElement('canvas'); const colCtx = colCanvas.getContext('2d');
  const recallCanvas = document.createElement('canvas'); const recallCtx = recallCanvas.getContext('2d');

  function fit(){
    const dpr = Math.max(1, window.devicePixelRatio||1);
    const r = can.final.getBoundingClientRect();
    const W = Math.max(2, Math.ceil(r.width*dpr));
    const H = Math.max(2, Math.ceil(r.height*dpr));
    for(const k in can){ can[k].width=W; can[k].height=H; }
    proc.width=W; proc.height=H; maskCanvas.width=W; maskCanvas.height=H; colCanvas.width=W; colCanvas.height=H; recallCanvas.width=W; recallCanvas.height=H;
  }
  new ResizeObserver(fit).observe(can.final); fit();

  /* ---------- Buffers ---------- */
  const buf=[]; const MAX_SEC=14;
  function pushFrame(img,t){ buf.push({t,data:new Uint8ClampedArray(img.data),w:img.width,h:img.height}); const cutoff=t-(MAX_SEC+2); while(buf.length && buf[0].t<cutoff) buf.shift(); }
  function getPastFrame(delta){ const target=vid.currentTime-delta; for(let i=buf.length-1;i>=0;i--){ if(buf[i].t<=target) return buf[i]; } return buf[0]||null; }

  function drawVideoContained(ctx, video, W, H, blurPx){
    ctx.save(); ctx.clearRect(0,0,W,H); if(blurPx>0) ctx.filter=`blur(${blurPx}px)`;
    const vw=video.videoWidth||0, vh=video.videoHeight||0;
    if(vw && vh){ const s=Math.min(W/vw,H/vh); const dw=Math.round(vw*s), dh=Math.round(vh*s); const dx=Math.floor((W-dw)/2), dy=Math.floor((H-dh)/2); ctx.drawImage(video,dx,dy,dw,dh); }
    ctx.restore();
  }

  /* ---------- Recording (Auto format) ---------- */
  let recorder=null, chunks=[], recStartTime=0, recTimer=null, recMime="", recExt="webm";
  function bestSupported(){
    const mp4='video/mp4;codecs=avc1.42E01E,mp4a.40.2', webm='video/webm;codecs=vp9,opus', webm2='video/webm;codecs=vp8,opus';
    const canMp4 = !!(window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(mp4));
    const canWebm= !!(window.MediaRecorder && MediaRecorder.isTypeSupported && (MediaRecorder.isTypeSupported(webm)||MediaRecorder.isTypeSupported(webm2)));
    return {canMp4, canWebm, mp4, webm:(MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(webm)?webm:webm2)};
  }
  function refreshSupportNote(){
    const s=bestSupported();
    const msg = s.canMp4 ? 'Auto → MP4' : (s.canWebm ? 'Auto → WebM' : '<span class="warn">Recording unsupported.</span>');
    supportNote.innerHTML = msg;
  }
  refreshSupportNote();

  function startRecording(){
    const s=bestSupported();
    const mime = s.canMp4 ? s.mp4 : (s.canWebm ? s.webm : '');
    if(!mime){ alert('Recording format not supported on this browser.'); return; }

    const stream = can.final.captureStream ? can.final.captureStream(30) : can.final.mozCaptureStream(30);
    chunks=[]; recorder = new MediaRecorder(stream,{mimeType:mime,videoBitsPerSecond:8_000_000});
    recMime=mime; recExt=mime.startsWith('video/mp4')?'mp4':'webm';
    recorder.ondataavailable=e=>{ if(e.data && e.data.size) chunks.push(e.data); };
    recorder.onstop=()=>{ const blob=new Blob(chunks,{type:recMime}); const a=document.createElement('a'); a.download=`wind_on_wall_${Date.now()}.${recExt}`; a.href=URL.createObjectURL(blob); a.click(); stopRecUI(); };
    recorder.start(250);

    recStartTime=performance.now();
    recTimer=setInterval(()=>{ const t=Math.floor((performance.now()-recStartTime)/1000); const mm=String(Math.floor(t/60)).padStart(2,'0'); const ss=String(t%60).padStart(2,'0'); recTime.textContent=`REC ${mm}:${ss}`; },250);
    recHUD.style.display='flex'; recStartBtn.disabled=true; recStopBtn.disabled=false;
  }
  function stopRecording(){ if(recorder && recorder.state==='recording'){ recorder.stop(); } }
  function stopRecUI(){ clearInterval(recTimer); recTimer=null; recHUD.style.display='none'; recStartBtn.disabled=false; recStopBtn.disabled=true; }
  recStartBtn.addEventListener('click', startRecording);
  recStopBtn.addEventListener('click',  stopRecording);

  shotBtn.addEventListener('click', ()=>{ const a=document.createElement('a'); a.download='still_'+Date.now()+'.png'; a.href=can.final.toDataURL('image/png'); a.click(); });

  /* ---------- Replay ---------- */
  function resetState(){ buf.length=0; sctx.clearRect(0,0,can.stain.width,can.stain.height); gctx.clearRect(0,0,can.ghost.width,can.ghost.height); recallBank.length=0; recallCtx.clearRect(0,0,recallCanvas.width,recallCanvas.height); activeBurst=null; }
  function replay(){
    if(vid.srcObject){ alert('Replay is for file/URL clips. Stop Webcam and load a clip to use Replay.'); return; }
    if(!vid.currentSrc && !vid.src){ alert('No clip loaded.'); return; }
    if(recorder && recorder.state==='recording'){ stopRecording(); }
    try{ vid.pause(); resetState(); const onSeeked=()=>{ vid.removeEventListener('seeked',onSeeked); vid.play(); }; vid.addEventListener('seeked',onSeeked,{once:true}); vid.currentTime=0; }
    catch(e){ const s=vid.currentSrc || vid.src; if(s){ resetState(); vid.src=s; vid.play(); } }
  }
  replayBtn.addEventListener('click', replay);
  replayFloat.addEventListener('click', replay);
  document.addEventListener('keydown', (e)=>{ const t=e.target; if(t&&(t.tagName==='INPUT'||t.tagName==='SELECT'||t.tagName==='TEXTAREA'||t.isContentEditable)) return; if(e.code==='KeyR'){ e.preventDefault(); replay(); } else if(e.code==='Space'){ e.preventDefault(); vid.paused?vid.play():vid.pause(); } });

  /* ---------- Recall ---------- */
  const recallOn = document.getElementById('recallOn');
  const recallProb = document.getElementById('recallProb'); const recallProbV = document.getElementById('recallProbV');
  const recallCap  = document.getElementById('recallCap');  const recallCapV  = document.getElementById('recallCapV');
  const recallNowB = document.getElementById('recallNow');
  const recallColor= document.getElementById('recallColor');
  const recallLinger=document.getElementById('recallLinger'); const recallLingerV=document.getElementById('recallLingerV');
  const recallSpan=document.getElementById('recallSpan'); const recallSpanV=document.getElementById('recallSpanV');

  function syncRecall(){ if(recallProbV)recallProbV.textContent=(+recallProb.value).toFixed(2); if(recallCapV)recallCapV.textContent=recallCap.value; if(recallLingerV)recallLingerV.textContent=(+recallLinger.value).toFixed(1); if(recallSpanV)recallSpanV.textContent=(+recallSpan.value).toFixed(1); }
  [recallOn,recallProb,recallCap,recallColor,recallLinger,recallSpan].forEach(x=>x&&x.addEventListener('input',syncRecall)); syncRecall();

  const recallBank=[]; let recallBurst=0; let activeBurst=null;
  function capRecallBank(max){ while(recallBank.length>max) recallBank.shift(); }
  async function snapshotGhost(tNow){
    try{
      let img; if('createImageBitmap' in window) img=await createImageBitmap(can.ghost);
      else { const c=document.createElement('canvas'); c.width=can.ghost.width; c.height=can.ghost.height; c.getContext('2d').drawImage(can.ghost,0,0); img=c; }
      recallBank.push({img,t:tNow}); capRecallBank((+recallCap.value|0)||40);
    }catch(_){}
  }
  function startRandomBurst(){
    if(!recallBank.length) return;
    const span=Math.max(0,+recallSpan.value||0);
    const r=(Math.random()*recallBank.length)|0;
    const t0=recallBank[r].t, t1=t0+span;
    const frames=recallBank.filter(f=>f.t>=t0 && f.t<=t1).map(f=>f.img);
    activeBurst={frames:frames.length?frames:[recallBank[r].img],i:0};
  }
  if(recallNowB) recallNowB.addEventListener('click', ()=>{ recallBurst+=1; });
  function drawTinted(dstCtx,src,color){ dstCtx.globalCompositeOperation='source-over'; dstCtx.drawImage(src,0,0); dstCtx.globalCompositeOperation='source-in'; dstCtx.fillStyle=color||'#00e7ff'; dstCtx.fillRect(0,0,recallCanvas.width,recallCanvas.height); dstCtx.globalCompositeOperation='source-over'; }

  /* ---------- Main loop ---------- */
  let lastT=performance.now(), fpsEMA=0, suspendLive=false;
  requestAnimationFrame(function tick(now){
    requestAnimationFrame(tick);
    if(suspendLive) return;

    const W=can.final.width, H=can.final.height;
    const grey=+el.grey.value; fctx.clearRect(0,0,W,H); fctx.fillStyle=`rgb(${grey},${grey},${grey})`; fctx.fillRect(0,0,W,H);

    if(vid.readyState<2){ nosrc.style.display='block'; return; } else { nosrc.style.display='none'; }

    drawVideoContained(pctx,vid,W,H,+el.preblur.value);
    const curr=pctx.getImageData(0,0,W,H); pushFrame(curr,vid.currentTime);
    const past=getPastFrame(+el.dt.value); if(!past) return;

    const c=curr.data, p=past.data; const ghostImg=gctx.createImageData(W,H); const gd=ghostImg.data; const thr=+el.thr.value; const mask=new Uint8ClampedArray(W*H); let changedCount=0;
    for(let i=0,j=0;i<c.length;i+=4,j++){
      const r=c[i], g=c[i+1], b=c[i+2]; const pr=p[i], pg=p[i+1], pb=p[i+2];
      const lc=r*0.2126+g*0.7152+b*0.0722; const lp=pr*0.2126+pg*0.7152+pb*0.0722; const d=Math.abs(lc-lp);
      if(d>thr){ changedCount++; mask[j]=255;
        if(gUseColor.checked){ const a=Math.max(40,Math.min(255,(d-thr)*8)); const m=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(gColor.value); const cr=m?parseInt(m[1],16):255, cg=m?parseInt(m[2],16):255, cb=m?parseInt(m[3],16):255; gd[i]=cr; gd[i+1]=cg; gd[i+2]=cb; gd[i+3]=a; }
        else { gd[i]=(r+(255-pr))*0.5; gd[i+1]=(g+(255-pg))*0.5; gd[i+2]=(b+(255-pb))*0.5; gd[i+3]=255; }
      } else { gd[i]=gd[i+1]=gd[i+2]=0; gd[i+3]=0; }
    }
    gctx.putImageData(ghostImg,0,0);

    if(stainOn.checked){
      const decay=+el.decay.value;
      sctx.globalCompositeOperation='destination-out'; sctx.fillStyle=`rgba(0,0,0,${1-decay})`; sctx.fillRect(0,0,W,H);
      sctx.globalCompositeOperation='source-over';
      const mImg=maskCtx.createImageData(W,H); const mdat=mImg.data;
      for(let j=0,k=0;j<mask.length;j++,k+=4){ const v=mask[j]; mdat[k]=mdat[k+1]=mdat[k+2]=v; mdat[k+3]=v; }
      maskCtx.putImageData(mImg,0,0);

      colCtx.clearRect(0,0,W,H); const expand=+el.expand.value; if(expand>0) colCtx.filter=`blur(${expand}px)`; colCtx.drawImage(maskCanvas,0,0); colCtx.filter='none';
      colCtx.globalCompositeOperation='source-in'; colCtx.fillStyle=sColor.value; colCtx.globalAlpha=+el.strength.value; colCtx.fillRect(0,0,W,H);
      colCtx.globalCompositeOperation='source-over'; colCtx.globalAlpha=1; sctx.drawImage(colCanvas,0,0);
    }

    if(stainOn.checked){ fctx.globalCompositeOperation='multiply'; fctx.drawImage(can.stain,0,0); fctx.globalCompositeOperation='source-over'; }
    fctx.globalAlpha=+el.gAlpha.value; fctx.globalCompositeOperation=gBlend.value; fctx.drawImage(can.ghost,0,0); fctx.globalAlpha=1; fctx.globalCompositeOperation='source-over';

    if(changedCount>0) snapshotGhost(vid.currentTime);
    if(recallOn && recallOn.checked){ const prob=+recallProb.value||0; if(Math.random()<prob && !activeBurst) startRandomBurst(); }
    { const lingerS=Math.max(0.2,+recallLinger.value||1.2); const ms=Math.max(1,now-lastT); const fade=1-Math.exp(-ms/(lingerS*1000)); recallCtx.globalCompositeOperation='destination-out'; recallCtx.fillStyle=`rgba(0,0,0,${fade})`; recallCtx.fillRect(0,0,recallCanvas.width,recallCanvas.height); recallCtx.globalCompositeOperation='source-over'; }
    if(activeBurst && activeBurst.frames && activeBurst.frames.length){ const color=recallColor?recallColor.value:'#00e7ff'; drawTinted(recallCtx,activeBurst.frames[activeBurst.i],color); activeBurst.i++; if(activeBurst.i>=activeBurst.frames.length) activeBurst=null; }
    fctx.globalCompositeOperation='screen'; fctx.drawImage(recallCanvas,0,0); fctx.globalCompositeOperation='source-over';

    const dt=now-lastT; lastT=now; const inst=dt>0?1000/dt:0; fpsEMA=fpsEMA?fpsEMA*0.9+inst*0.1:inst;
    const s=bestSupported(); dbg.textContent=`buffer: ${buf.length} | fps ~ ${fpsEMA.toFixed(1)} | support: ${s.canMp4?'MP4✓':'MP4×'}/${s.canWebm?'WebM✓':'WebM×'}`;
  });

  vid.addEventListener('loadeddata', ()=>{ vid.play().catch(()=>{}); });

  /* ---------- Export 1:1 (Auto format) ---------- */
  exportOneBtn.addEventListener('click', exportSourceOnce);
  async function exportSourceOnce(){
    if(vid.srcObject){ alert('1:1 export is for file/URL clips, not webcam.'); return; }
    if(!(vid.currentSrc || vid.src)){ alert('Load a clip first.'); return; }
    if(vid.readyState<1){ await new Promise(res=>vid.addEventListener('loadedmetadata',res,{once:true})); }
    const vw=vid.videoWidth|0, vh=vid.videoHeight|0; if(!vw||!vh){ alert('Video metadata unavailable.'); return; }

    const s=bestSupported(); let mime='',ext='webm';
    if(s.canMp4){ mime=s.mp4; ext='mp4'; }
    else if(s.canWebm){ mime=s.webm; ext='webm'; }
    else { alert('Export not supported on this browser. Try Safari (MP4) or Chrome/Firefox (WebM).'); return; }

    exportOneBtn.disabled=true; recStartBtn.disabled=true; const prevSuspend=false; let suspendLive=prevSuspend;

    const outCanvas=document.createElement('canvas'); outCanvas.width=vw; outCanvas.height=vh; const octx=outCanvas.getContext('2d');
    const expChunks=[]; const stream=outCanvas.captureStream?outCanvas.captureStream(30):outCanvas.mozCaptureStream(30);
    const expRecorder=new MediaRecorder(stream,{mimeType:mime,videoBitsPerSecond:8_000_000});
    const recDone=new Promise(resolve=>{ expRecorder.ondataavailable=e=>{ if(e.data && e.data.size) expChunks.push(e.data); }; expRecorder.onstop=resolve; });

    const prev={ loop:vid.loop, rate:vid.playbackRate, paused:vid.paused, t:vid.currentTime };
    vid.pause(); vid.loop=false; vid.playbackRate=1;

    const nativeProcessing=!matchPreview.checked;
    const prevSizes={W:can.final.width,H:can.final.height,sW:can.stain.width,sH:can.stain.height,gW:can.ghost.width,gH:can.ghost.height,pW:proc.width,pH:proc.height,mW:maskCanvas.width,mH:maskCanvas.height,cW:colCanvas.width,cH:colCanvas.height};
    if(nativeProcessing){ [can.stain,can.ghost,can.final,proc,maskCanvas,colCanvas].forEach(c=>{ c.width=vw; c.height=vh; }); recallCanvas.width=vw; recallCanvas.height=vh; recallCtx.clearRect(0,0,recallCanvas.width,recallCanvas.height); }

    function drawContain(srcCanvas,dstCtx,dstW,dstH){ const sw=srcCanvas.width, sh=srcCanvas.height; const s=Math.min(dstW/sw,dstH/sh); const dw=Math.round(sw*s), dh=Math.round(sh*s); const dx=Math.floor((dstW-dw)/2), dy=Math.floor((dstH-dh)/2); dstCtx.clearRect(0,0,dstW,dstH); dstCtx.drawImage(srcCanvas,dx,dy,dw,dh); }
    function blitToOut(){ if(matchPreview.checked) drawContain(can.final,octx,vw,vh); else { octx.clearRect(0,0,vw,vh); octx.drawImage(can.final,0,0,vw,vh); } }
    function exportDecayStep(){ const lingerS=Math.max(0.2,+recallLinger.value||1.2); const fade=1-Math.exp(-1/(lingerS*30)); recallCtx.globalCompositeOperation='destination-out'; recallCtx.fillStyle=`rgba(0,0,0,${fade})`; recallCtx.fillRect(0,0,recallCanvas.width,recallCanvas.height); recallCtx.globalCompositeOperation='source-over'; }

    function processOneFrame(W,H){
      const grey=+el.grey.value; fctx.clearRect(0,0,W,H); fctx.fillStyle=`rgb(${grey},${grey},${grey})`; fctx.fillRect(0,0,W,H);
      drawVideoContained(pctx,vid,W,H,+el.preblur.value); const curr=pctx.getImageData(0,0,W,H); pushFrame(curr,vid.currentTime);
      const past=getPastFrame(+el.dt.value);
      if(past){
        const c=curr.data, p=past.data; const ghostImg=gctx.createImageData(W,H); const gd=ghostImg.data; const thr=+el.thr.value; const mask=new Uint8ClampedArray(W*H);
        for(let i=0,j=0;i<c.length;i+=4,j++){
          const r=c[i],g=c[i+1],b=c[i+2]; const pr=p[i],pg=p[i+1],pb=p[i+2];
          const lc=r*0.2126+g*0.7152+b*0.0722; const lp=pr*0.2126+pg*0.7152+pb*0.0722; const d=Math.abs(lc-lp);
          if(d>thr){ mask[j]=255;
            if(gUseColor.checked){ const m=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(gColor.value); const cr=m?parseInt(m[1],16):255,cg=m?parseInt(m[2],16):255,cb=m?parseInt(m[3],16):255; const a=Math.max(40,Math.min(255,(d-thr)*8)); gd[i]=cr; gd[i+1]=cg; gd[i+2]=cb; gd[i+3]=a; }
            else { gd[i]=(r+(255-pr))*0.5; gd[i+1]=(g+(255-pg))*0.5; gd[i+2]=(b+(255-pb))*0.5; gd[i+3]=255; }
          } else { gd[i]=gd[i+1]=gd[i+2]=0; gd[i+3]=0; }
        }
        gctx.putImageData(ghostImg,0,0);

        if(stainOn.checked){
          const decay=+el.decay.value; sctx.globalCompositeOperation='destination-out'; sctx.fillStyle=`rgba(0,0,0,${1-decay})`; sctx.fillRect(0,0,W,H); sctx.globalCompositeOperation='source-over';
          const mImg=maskCtx.createImageData(W,H); const mdat=mImg.data; for(let j=0,k=0;j<mask.length;j++,k+=4){ const v=mask[j]; mdat[k]=mdat[k+1]=mdat[k+2]=v; mdat[k+3]=v; } maskCtx.putImageData(mImg,0,0);
          colCtx.clearRect(0,0,W,H); const expand=+el.expand.value; if(expand>0) colCtx.filter=`blur(${expand}px)`; colCtx.drawImage(maskCanvas,0,0); colCtx.filter='none';
          colCtx.globalCompositeOperation='source-in'; colCtx.fillStyle=sColor.value; colCtx.globalAlpha=+el.strength.value; colCtx.fillRect(0,0,W,H);
          colCtx.globalCompositeOperation='source-over'; colCtx.globalAlpha=1; sctx.drawImage(colCanvas,0,0);
        }
      }

      if(stainOn.checked){ fctx.globalCompositeOperation='multiply'; fctx.drawImage(can.stain,0,0); fctx.globalCompositeOperation='source-over'; }
      fctx.globalAlpha=+el.gAlpha.value; fctx.globalCompositeOperation=gBlend.value; fctx.drawImage(can.ghost,0,0); fctx.globalAlpha=1; fctx.globalCompositeOperation='source-over';

      if(vid && !isNaN(vid.currentTime)) snapshotGhost(vid.currentTime);
      if(recallOn && recallOn.checked){ const prob=+recallProb.value||0; if(Math.random()<prob && !activeBurst) startRandomBurst(); }
      exportDecayStep();
      if(activeBurst && activeBurst.frames && activeBurst.frames.length){ const color=recallColor?recallColor.value:'#00e7ff'; drawTinted(recallCtx,activeBurst.frames[activeBurst.i],color); activeBurst.i++; if(activeBurst.i>=activeBurst.frames.length) activeBurst=null; }
      fctx.globalCompositeOperation='screen'; fctx.drawImage(recallCanvas,0,0); fctx.globalCompositeOperation='source-over';
    }

    await new Promise(res=>{ const h=()=>{vid.removeEventListener('seeked',h); res();}; vid.addEventListener('seeked',h); try{ vid.currentTime=0; }catch(_){ res(); } });
    expRecorder.start(250); processOneFrame(can.final.width,can.final.height); blitToOut();

    const hasVFC=typeof vid.requestVideoFrameCallback==='function'; let vfcId=null, rafId=null;
    function stopDrivers(){ if(vfcId && vid.cancelVideoFrameCallback) try{vid.cancelVideoFrameCallback(vfcId);}catch(_){} if(rafId) cancelAnimationFrame(rafId); vfcId=rafId=null; }
    function loop(){ processOneFrame(can.final.width,can.final.height); blitToOut(); if(hasVFC) vfcId=vid.requestVideoFrameCallback(()=>loop()); else rafId=requestAnimationFrame(loop); }

    const safety=setTimeout(()=>{ try{vid.pause();}catch(_){}; finalize(); }, (isFinite(vid.duration)?vid.duration:60)*1000+15000);
    function finalize(){ clearTimeout(safety); stopDrivers(); try{expRecorder.stop();}catch(_){} }
    vid.addEventListener('ended',finalize,{once:true}); await vid.play().catch(()=>{}); loop(); await recDone;

    const blob=new Blob(expChunks,{type:mime}); const a=document.createElement('a'); const tag=matchPreview.checked?'match':'native';
    a.download=`wind_on_wall_1x_${vw}x${vh}_${tag}_${Date.now()}.${ext}`; a.href=URL.createObjectURL(blob); a.click();

    if(nativeProcessing){ can.final.width=prevSizes.W; can.final.height=prevSizes.H; can.stain.width=prevSizes.sW; can.stain.height=prevSizes.sH; can.ghost.width=prevSizes.gW; can.ghost.height=prevSizes.gH; proc.width=prevSizes.pW; proc.height=prevSizes.pH; maskCanvas.width=prevSizes.mW; maskCanvas.height=prevSizes.mH; colCanvas.width=prevSizes.cW; colCanvas.height=prevSizes.cH; }
    vid.loop=prev.loop; vid.playbackRate=prev.rate; try{ vid.currentTime=prev.t; }catch(_){}
    if(!prev.paused){ try{ await vid.play(); }catch(_){ } }
    exportOneBtn.disabled=false; recStartBtn.disabled=false;
  }
})();
</script>

<!-- Slider fill % helper (for the dark-left / light-right track) -->
<script>
(function(){
  function paint(r){ var min=r.min?+r.min:0, max=r.max?+r.max:100, val=isNaN(+r.value)?min:+r.value, p=((val-min)/(max-min))*100; r.style.setProperty('--p', p+'%'); }
  var ranges=document.querySelectorAll('input[type="range"]');
  ranges.forEach(function(r){ paint(r); r.addEventListener('input', function(){ paint(r); }); });
})();
</script>
</body>
</html>
