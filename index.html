// Helper: match preview sharpness but lock to source aspect ratio
function pickExportDimsGoalB(prevSizes, vid) {
  // source aspect ratio
  const ar = (vid.videoWidth || 1) / (vid.videoHeight || 1);

  // start from preview backing buffer
  let w = prevSizes.W | 0;
  let h = prevSizes.H | 0;

  // adjust preview dims so aspect ratio matches source exactly
  const previewAR = w / h;
  if (Math.abs(previewAR - ar) > 0.001) {
    if (previewAR > ar) {
      // preview is "wider" than source AR → reduce width
      w = Math.round(h * ar);
    } else {
      // preview is "taller" than source AR → reduce height
      h = Math.round(w / ar);
    }
  }

  // enforce even dimensions so encoder won't force-rescale
  if (w % 2) w -= 1;
  if (h % 2) h -= 1;

  // scalePx = 1 because we're intentionally using preview-scale rendering
  return { W: w, H: h, scalePx: 1 };
}

// Helper: resize all working buffers to a given W,H
function resizeAllWorkingBuffers(W, H) {
  can.final.width  = W; can.final.height  = H;
  can.stain.width  = W; can.stain.height  = H;
  can.ghost.width  = W; can.ghost.height  = H;
  proc.width       = W; proc.height       = H;
  maskCanvas.width = W; maskCanvas.height = H;
  colCanvas.width  = W; colCanvas.height  = H;
  recallCanvas.width = W; recallCanvas.height = H;
  hauntCanvas.width  = W; hauntCanvas.height  = H;
  tintCanvas.width   = W; tintCanvas.height   = H;
  edgeCanvas.width   = W; edgeCanvas.height   = H;
  ensureEdgeBuffers(W, H, true);

  // clear state so we start clean at t=0
  buf.length = 0;
  sctx.clearRect(0,0,W,H);
  gctx.clearRect(0,0,W,H);
  recallBank.length = 0;
  recallCtx.clearRect(0,0,W,H);
  activeBurst = null;
  hauntCtx.clearRect(0,0,W,H);
  tintCtx.clearRect(0,0,W,H);
  edgeCtx.clearRect(0,0,W,H);
}

// **REPLACE ONLY THIS FUNCTION IN YOUR FILE**
async function exportSourceOnce(){
  if(vid.srcObject){
    alert('1:1 export is for file/URL clips, not webcam.');
    return;
  }
  if(!(vid.currentSrc || vid.src)){
    alert('Load a clip first.');
    return;
  }
  if(vid.readyState<1){
    await new Promise(res=>vid.addEventListener('loadedmetadata',res,{once:true}));
  }
  const vW = vid.videoWidth|0;
  const vH = vid.videoHeight|0;
  if(!vW || !vH){
    alert('Video metadata unavailable.');
    return;
  }

  const s = bestSupported();
  let mime='',ext='webm';
  if(s.canMp4){ mime=s.mp4; ext='mp4'; }
  else if(s.canWebm){ mime=s.webm; ext='webm'; }
  else {
    alert('Export not supported on this browser. Try Safari (MP4) or Chrome/Firefox (WebM).');
    return;
  }

  // pause live preview loop during export
  const prevSuspend = suspendLive;
  suspendLive = true;

  exportOneBtn.disabled=true;
  recStartBtn.disabled=true;

  // snapshot current preview backing sizes so we can restore after
  const prevSizes = {
    W: can.final.width,  H: can.final.height,
    sW: can.stain.width, sH: can.stain.height,
    gW: can.ghost.width, gH: can.ghost.height,
    pW: proc.width,      pH: proc.height,
    mW: maskCanvas.width,mH: maskCanvas.height,
    cW: colCanvas.width, cH: colCanvas.height,
    rW: recallCanvas.width, rH: recallCanvas.height,
    hW: hauntCanvas.width,  hH: hauntCanvas.height,
    tW: tintCanvas.width,   tH: tintCanvas.height,
    eW: edgeCanvas.width,   eH: edgeCanvas.height
  };

  // === NEW: choose export dims using Goal B logic ===
  const { W: outW, H: outH, scalePx } = pickExportDimsGoalB(prevSizes, vid);

  // resize all working buffers to export resolution (and clear accumulators)
  resizeAllWorkingBuffers(outW, outH);

  // prepare dedicated output canvas for capture
  const outCanvas = document.createElement('canvas');
  outCanvas.width  = outW;
  outCanvas.height = outH;
  const octx = outCanvas.getContext('2d');

  // bitrate heuristic: ~0.07 bits-per-pixel-per-frame @30fps, clamped
  const fps = 30;
  const vbr = Math.min(
    25_000_000,
    Math.max(8_000_000, Math.floor(outW*outH*fps*0.07))
  );

  const stream = outCanvas.captureStream(fps);
  const expChunks = [];
  const expRecorder = new MediaRecorder(stream,{
    mimeType: mime,
    videoBitsPerSecond: vbr
  });

  const recDone = new Promise(resolve=>{
    expRecorder.ondataavailable = e=>{
      if(e.data && e.data.size) expChunks.push(e.data);
    };
    expRecorder.onstop = resolve;
  });

  // deterministic offline stepping instead of vid.play()
  const duration = isFinite(vid.duration) ? vid.duration : 60;
  const frameDt  = 1/fps;
  let tCursor    = 0;
  let stopped    = false;

  // local export-only buffers (we do NOT want to mutate live recall state etc.)
  const exportBuf = [];
  const exportRecallBank = [];
  const exportActiveBurstRef = { value:null };

  // seek helper: jump video to t, wait until that frame is decoded
  function seekToTime(t){
    return new Promise(res=>{
      function onSeek(){
        vid.removeEventListener('seeked',onSeek);
        res();
      }
      vid.addEventListener('seeked',onSeek);
      try{
        vid.currentTime = Math.min(duration, t);
      }catch(_){
        vid.removeEventListener('seeked',onSeek);
        res();
      }
    });
  }

  // bag of contexts/state we pass into renderCompositeFrame
  function makeExportStateBag(){
    return {
      localBuf: exportBuf,
      localRecallBank: exportRecallBank,
      localActiveBurst: exportActiveBurstRef,
      setActiveBurst: v=>{ exportActiveBurstRef.value=v; },
      currRecallCtx: recallCtx,
      currRecallCanvas: recallCanvas,
      currHauntCtx: hauntCtx,
      currHauntCanvas: hauntCanvas,
      currTintCtx: tintCtx,
      currTintCanvas: tintCanvas,
      currEdgeCtx: edgeCtx,
      currEdgeCanvas: edgeCanvas,
      forceSnapshotGhost: async (tNow)=>{
        // take snapshot of ghost layer into exportRecallBank
        await (async ()=>{
          try{
            let img;
            if('createImageBitmap' in window){
              img = await createImageBitmap(can.ghost);
            } else {
              const c=document.createElement('canvas');
              c.width=can.ghost.width;
              c.height=can.ghost.height;
              c.getContext('2d').drawImage(can.ghost,0,0);
              img=c;
            }
            exportRecallBank.push({img,t:tNow});
            // cap capacity using current UI control
            const cap = (+recallCap.value|0)||40;
            while(exportRecallBank.length>cap) exportRecallBank.shift();
          }catch(_){}
        })();
      }
    };
  }

  async function renderFrameAtTime(tNow){
    // draw 1 frame of the effect graph at export resolution
    renderCompositeFrame(
      outW, outH,
      tNow,
      scalePx,       // <- pixel scaling (1 for Goal B)
      makeExportStateBag()
    );

    // blit final composited frame to the recorder canvas
    octx.clearRect(0,0,outW,outH);
    octx.drawImage(can.final,0,0,outW,outH);
  }

  function finalizeExport(){
    if(stopped) return;
    stopped = true;
    try{ expRecorder.stop(); }catch(_){}
  }

  // after recorder fully stops: save file, restore state, resume preview
  recDone.then(()=>{
    // download
    const blob=new Blob(expChunks,{type:mime});
    const a=document.createElement('a');
    a.download=`wind_on_wall_previewQual_ARlocked_${outW}x${outH}_${Date.now()}.${ext}`;
    a.href=URL.createObjectURL(blob);
    a.click();

    // restore all working buffers back to preview backing sizes
    can.final.width  = prevSizes.W; can.final.height  = prevSizes.H;
    can.stain.width  = prevSizes.sW; can.stain.height = prevSizes.sH;
    can.ghost.width  = prevSizes.gW; can.ghost.height = prevSizes.gH;
    proc.width       = prevSizes.pW; proc.height      = prevSizes.pH;
    maskCanvas.width = prevSizes.mW; maskCanvas.height= prevSizes.mH;
    colCanvas.width  = prevSizes.cW; colCanvas.height = prevSizes.cH;
    recallCanvas.width = prevSizes.rW; recallCanvas.height = prevSizes.rH;
    hauntCanvas.width  = prevSizes.hW; hauntCanvas.height  = prevSizes.hH;
    tintCanvas.width   = prevSizes.tW; tintCanvas.height   = prevSizes.tH;
    edgeCanvas.width   = prevSizes.eW; edgeCanvas.height   = prevSizes.eH;
    ensureEdgeBuffers(can.final.width, can.final.height, true);

    // resume live rendering
    suspendLive = prevSuspend;
    exportOneBtn.disabled=false;
    recStartBtn.disabled=false;
  });

  // init export session
  try{ vid.pause(); }catch(_){}
  vid.loop=false;
  vid.playbackRate=1;

  expRecorder.start(250);

  // deterministic timeline loop @fps
  async function stepLoop(){
    if(stopped) return;
    if(tCursor > duration + 0.0001){
      finalizeExport();
      return;
    }

    await seekToTime(tCursor);
    await renderFrameAtTime(tCursor);

    tCursor += frameDt;

    // yield so UI thread doesn't starve
    setTimeout(stepLoop,0);
  }
  stepLoop();

  // safety kill in case "ended" never triggers (we're not using vid.play())
  const safetyMs = duration*1000 + 15000;
  setTimeout(()=>{ finalizeExport(); }, safetyMs);
}
