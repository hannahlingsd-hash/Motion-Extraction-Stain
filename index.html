/* ---------- Export 1:1 ---------- */
  exportOneBtn.addEventListener('click', exportSourceOnce);
  async function exportSourceOnce(){
    if(vid.srcObject){ alert('1:1 export is for file/URL clips, not webcam.'); return; }
    if(!(vid.currentSrc || vid.src)){ alert('Load a clip first.'); return; }
    if(vid.readyState<1){ await new Promise(res=>vid.addEventListener('loadedmetadata',res,{once:true})); }
    const vw=vid.videoWidth|0, vh=vid.videoHeight|0; if(!vw||!vh){ alert('Video metadata unavailable.'); return; }

    const s=bestSupported(); let mime='',ext='webm';
    if(s.canMp4){ mime=s.mp4; ext='mp4'; }
    else if(s.canWebm){ mime=s.webm; ext='webm'; }
    else { alert('Export not supported on this browser. Try Safari (MP4) or Chrome/Firefox (WebM).'); return; }

    exportOneBtn.disabled=true; recStartBtn.disabled=true;

    const outCanvas=document.createElement('canvas'); outCanvas.width=vw; outCanvas.height=vh; const octx=outCanvas.getContext('2d');
    const expChunks=[]; const stream=outCanvas.captureStream?outCanvas.captureStream(30):outCanvas.mozCaptureStream(30);
    const expRecorder=new MediaRecorder(stream,{mimeType:mime,videoBitsPerSecond:12_000_000});
    const recDone=new Promise(resolve=>{ expRecorder.ondataavailable=e=>{ if(e.data && e.data.size) expChunks.push(e.data); }; expRecorder.onstop=resolve; });

    const prev={ loop:vid.loop, rate:vid.playbackRate, paused:vid.paused, t:vid.currentTime };
    vid.pause(); vid.loop=false; vid.playbackRate=1;

    // ALWAYS process at native video resolution for 1:1 export
    const prevSizes={W:can.final.width,H:can.final.height,sW:can.stain.width,sH:can.stain.height,gW:can.ghost.width,gH:can.ghost.height,pW:proc.width,pH:proc.height,mW:maskCanvas.width,mH:maskCanvas.height,cW:colCanvas.width,cH:colCanvas.height,hW:hauntCanvas.width,hH:hauntCanvas.height,tW:tintCanvas.width,tH:tintCanvas.height,eW:edgeCanvas.width,eH:edgeCanvas.height};
    [can.stain,can.ghost,can.final,proc,maskCanvas,colCanvas,hauntCanvas,tintCanvas,edgeCanvas,edgeLayerCanvas].forEach(c=>{ c.width=vw; c.height=vh; });
    recallCanvas.width=vw; recallCanvas.height=vh; recallCtx.clearRect(0,0,recallCanvas.width,recallCanvas.height);

    function processOneFrame(W,H){
      const grey=+el.grey.value; fctx.clearRect(0,0,W,H); fctx.fillStyle=`rgb(${grey},${grey},${grey})`; fctx.fillRect(0,0,W,H);
      // Draw video at full resolution (no containment for 1:1 export)
      pctx.clearRect(0,0,W,H); pctx.drawImage(vid,0,0,W,H);
      const curr=pctx.getImageData(0,0,W,H); pushFrame(curr,vid.currentTime);
      const past=getPastFrame(+el.dt.value);
      if(past){
        const c=curr.data, p=past.data; const ghostImg=gctx.createImageData(W,H); const gd=ghostImg.data; const thr=+el.thr.value; const mask=new Uint8ClampedArray(W*H);
        for(let i=0,j=0;i<c.length;i+=4,j++){
          const r=c[i],g=c[i+1],b=c[i+2]; const pr=p[i],pg=p[i+1],pb=p[i+2];
          const lc=r*0.2126+g*0.7152+b*0.0722; const lp=pr*0.2126+pg*0.7152+pb*0.0722; const d=Math.abs(lc-lp);
          if(d>thr){ mask[j]=255;
            if(gUseColor.checked){
              const m=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(gColor.value);
              const cr=m?parseInt(m[1],16):255,cg=m?parseInt(m[2],16):255,cb=m?parseInt(m[3],16):255;
              const a=Math.max(40,Math.min(255,(d-thr)*8)); gd[i]=cr; gd[i+1]=cg; gd[i+2]=cb; gd[i+3]=a;
            } else {
              gd[i]=(r+(255-pr))*0.5; gd[i+1]=(g+(255-pg))*0.5; gd[i+2]=(b+(255-pb))*0.5; gd[i+3]=255;
            }
          } else { gd[i]=gd[i+1]=gd[i+2]=0; gd[i+3]=0; }
        }
        gctx.putImageData(ghostImg,0,0);

        if(stainOn.checked){
          const decay=+el.decay.value; sctx.globalCompositeOperation='destination-out'; sctx.fillStyle=`rgba(0,0,0,${1-decay})`; sctx.fillRect(0,0,W,H);
          sctx.globalCompositeOperation='source-over';
          const mImg=maskCtx.createImageData(W,H); const mdat=mImg.data;
          for(let j=0,k=0;j<mask.length;j++,k+=4){ const v=mask[j]; mdat[k]=mdat[k+1]=mdat[k+2]=v; mdat[k+3]=v; }
          maskCtx.putImageData(mImg,0,0);

          colCtx.clearRect(0,0,W,H); const expand=+el.expand.value; if(expand>0) colCtx.filter=`blur(${expand}px)`; colCtx.drawImage(maskCanvas,0,0); colCtx.filter='none';
          colCtx.globalCompositeOperation='source-in'; colCtx.fillStyle=sColor.value; colCtx.globalAlpha=+el.strength.value; colCtx.fillRect(0,0,W,H);
          colCtx.globalCompositeOperation='source-over'; colCtx.globalAlpha=1; sctx.drawImage(colCanvas,0,0);
        }
      }

      if(stainOn.checked){ fctx.globalCompositeOperation='multiply'; fctx.drawImage(can.stain,0,0); fctx.globalCompositeOperation='source-over'; }
      fctx.globalAlpha=+el.gAlpha.value; fctx.globalCompositeOperation=gBlend.value; fctx.drawImage(can.ghost,0,0); fctx.globalAlpha=1; fctx.globalCompositeOperation='source-over';

      if(vid && !isNaN(vid.currentTime)) snapshotGhost(vid.currentTime);
      if(recallOn && recallOn.checked){ const prob=+recallProb.value||0; if(Math.random()<prob && !activeBurst) startRandomBurst(); }
      exportDecayStep();
      if(activeBurst && activeBurst.frames && activeBurst.frames.length){
        const color=recallColor?recallColor.value:'#00e7ff';
        drawTinted(recallCtx, activeBurst.frames[activeBurst.i], color);
        activeBurst.i++;
        if(activeBurst.i>=activeBurst.frames.length) activeBurst=null;
      }
      fctx.globalCompositeOperation='screen'; fctx.drawImage(recallCanvas,0,0); fctx.globalCompositeOperation='source-over';

      /* outlines during export */
      const TH = (+edgeThr.value | 0) || 40;
      const TL = Math.max(0, Math.floor(TH * 0.5));
      function rgbaFrom(hex, a01){
        const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex||'#000000');
        return [parseInt(m[1],16), parseInt(m[2],16), parseInt(m[3],16), Math.max(0,Math.min(1,a01||1))];
      }
      function drawOutlineFrom(srcCanvas, colorHex, alpha01){
        const W = srcCanvas.width, H = srcCanvas.height; if(!W||!H) return;
        const sctx = srcCanvas.getContext('2d');
        const img  = sctx.getImageData(0,0,W,H);
        const d    = img.data;
        const L = new Uint8ClampedArray(W*H);
        for (let i=0,j=0;i<d.length;i+=4,++j){
          const lum = d[i]*0.2126 + d[i+1]*0.7152 + d[i+2]*0.0722;
          const a   = d[i+3];
          L[j] = Math.max(lum, a);
        }
        const E = new Uint8ClampedArray(W*H);
        for (let y=1;y<H-1;y++){
          let idx=y*W+1;
          for (let x=1;x<W-1;x++,idx++){
            const a=L[idx-W-1], b=L[idx-W], c=L[idx-W+1];
            const d0=L[idx-1],              f=L[idx+1];
            const g=L[idx+W-1], h=L[idx+W], i=L[idx+W+1];
            const gx = -a -2*b -c + g +2*h + i;
            const gy = -a -2*d0 -g + c +2*f + i;
            const mag = Math.abs(gx) + Math.abs(gy);
            let aa; if(mag>=TH) aa=255; else if(mag<=TL) aa=0; else aa=Math.round((mag-TL)/(TH-TL)*255);
            E[idx]=aa;
          }
        }
        for (let i=0,j=0;i<d.length;i+=4,++j){ E[j] = Math.round(E[j] * (d[i+3]/255)); }

        edgeLayerCtx.clearRect(0,0,edgeLayerCanvas.width,edgeLayerCanvas.height);
        const [r,g,b,a01] = rgbaFrom(colorHex, alpha01);
        const mask = edgeLayerCtx.createImageData(W,H);
        const md = mask.data;
        for (let j=0,p=0;j<E.length;j++,p+=4){
          const a = E[j]; if(!a){ md[p]=md[p+1]=md[p+2]=md[p+3]=0; continue; }
          md[p]=r; md[p+1]=g; md[p+2]=b; md[p+3]=Math.min(255, Math.round(a*a01));
        }
        edgeLayerCtx.putImageData(mask,0,0);

        edgeCtx.globalCompositeOperation='source-over';
        edgeCtx.drawImage(edgeLayerCanvas,0,0);
      }

      edgeCtx.clearRect(0,0,edgeCanvas.width,edgeCanvas.height);
      if (ghostEdgeOn && ghostEdgeOn.checked)   drawOutlineFrom(can.ghost,    ghostEdgeColor.value,  +ghostEdgeAlpha.value||0.8);
      if (stainEdgeOn && stainEdgeOn.checked)   drawOutlineFrom(can.stain,    stainEdgeColor.value,  +stainEdgeAlpha.value||0.7);
      if (recallEdgeOn && recallEdgeOn.checked) drawOutlineFrom(recallCanvas, recallEdgeColor.value, +recallEdgeAlpha.value||0.7);
      if (lingerEdgeOn && lingerEdgeOn.checked) drawOutlineFrom(hauntCanvas,  lingerEdgeColor.value, +lingerEdgeAlpha.value||0.8);
      fctx.drawImage(edgeCanvas,0,0);
    }

    function exportDecayStep(){ const lingerS=Math.max(0.2,+recallLinger.value||1.2); const fade=1-Math.exp(-1/(lingerS*30)); recallCtx.globalCompositeOperation='destination-out'; recallCtx.fillStyle=`rgba(0,0,0,${fade})`; recallCtx.fillRect(0,0,recallCanvas.width,recallCanvas.height); recallCtx.globalCompositeOperation='source-over'; }

    await new Promise(res=>{ const h=()=>{vid.removeEventListener('seeked',h); res();}; vid.addEventListener('seeked',h); try{ vid.currentTime=0; }catch(_){ res(); } });
    expRecorder.start(250); processOneFrame(vw,vh); octx.drawImage(can.final,0,0);

    const hasVFC=typeof vid.requestVideoFrameCallback==='function'; let vfcId=null, rafId=null;
    function stopDrivers(){ if(vfcId && vid.cancelVideoFrameCallback) try{vid.cancelVideoFrameCallback(vfcId);}catch(_){} if(rafId) cancelAnimationFrame(rafId); vfcId=rafId=null; }
    function loop(){ processOneFrame(vw,vh); octx.drawImage(can.final,0,0); if(hasVFC) vfcId=vid.requestVideoFrameCallback(()=>loop()); else rafId=requestAnimationFrame(loop); }

    const safety=setTimeout(()=>{ try{vid.pause();}catch(_){}; finalize(); }, (isFinite(vid.duration)?vid.duration:60)*1000+15000);
    function finalize(){ clearTimeout(safety); stopDrivers(); try{expRecorder.stop();}catch(_){} }
    vid.addEventListener('ended',finalize,{once:true}); await vid.play().catch(()=>{}); loop(); await recDone;

    const blob=new Blob(expChunks,{type:mime}); const a=document.createElement('a');
    a.download=`wind_on_wall_1x_${vw}x${vh}_${Date.now()}.${ext}`; a.href=URL.createObjectURL(blob); a.click();

    can.final.width=prevSizes.W; can.final.height=prevSizes.H;
    can.stain.width=prevSizes.sW; can.stain.height=prevSizes.sH;
    can.ghost.width=prevSizes.gW; can.ghost.height=prevSizes.gH;
    proc.width=prevSizes.pW; proc.height=prevSizes.pH;
    maskCanvas.width=prevSizes.mW; maskCanvas.height=prevSizes.mH;
    colCanvas.width=prevSizes.cW; colCanvas.height=prevSizes.cH;
    hauntCanvas.width=prevSizes.hW; hauntCanvas.height=prevSizes.hH;
    tintCanvas.width=prevSizes.tW; tintCanvas.height=prevSizes.tH;
    edgeCanvas.width=prevSizes.eW; edgeCanvas.height=prevSizes.eH;
    edgeLayerCanvas.width=prevSizes.eW; edgeLayerCanvas.height=prevSizes.eH;
    vid.loop=prev.loop; vid.playbackRate=prev.rate; try{ vid.currentTime=prev.t; }catch(_){}
    if(!prev.paused){ try{ await vid.play(); }catch(_){ } }
    exportOneBtn.disabled=false; recStartBtn.disabled=false;
  }
