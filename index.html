<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Wind-on-Wall — Ghosts + Stain + Recall (with fixed 1:1 export)</title>
<style>
  :root{--bg:#0b0e12;--fg:#e6eeff;--mut:#90a1bb;--accent:#ff5b5b}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font:14px/1.35 system-ui,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{display:grid;grid-template-columns:380px 1fr;gap:14px;height:100%}
  aside{padding:14px 12px 16px;border-right:1px solid #1a2233;overflow:auto}
  main{position:relative}
  canvas{position:absolute;inset:0;width:100%;height:100%;object-fit:contain;background:#000}
  h1{font-size:16px;margin:0 0 10px}
  fieldset{border:1px solid #1a2233;border-radius:10px;margin:10px 0;padding:10px}
  legend{padding:0 6px;color:#9fb7e8}
  .row{display:flex;align-items:center;gap:8px;margin:8px 0;flex-wrap:wrap}
  .row label{flex:1;color:var(--mut)}
  .row input[type="range"], .row select{flex:2}
  .btn{appearance:none;border:1px solid #2a3754;background:#121826;color:#cfe1ff;border-radius:8px;padding:6px 10px;cursor:pointer}
  .btn.secondary{background:#0e1422;border-color:#1f2b44;color:#a8b7d6}
  .btn:disabled{opacity:.5;cursor:not-allowed}
  .kbd{font:12px ui-monospace;background:#121520;border:1px solid #1f2736;border-radius:6px;padding:1px 6px;color:#b8c7e8}
  .small{font-size:12px;color:#93a6c4}
  .hud{position:absolute;top:10px;left:10px;background:rgba(0,0,0,.45);padding:6px 8px;border-radius:8px;font:12px ui-monospace;white-space:pre}
  .rec{position:absolute;top:10px;right:10px;background:rgba(0,0,0,.55);padding:6px 10px;border-radius:999px;font:12px ui-monospace;display:flex;align-items:center;gap:8px}
  .dot{width:8px;height:8px;background:var(--accent);border-radius:50%;box-shadow:0 0 8px var(--accent)}
  .warn{color:#ffb86b}
  .ok{color:#6be77a}
  .nosrc{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;color:#aac; font:12px ui-monospace; pointer-events:none}
  .fab{position:absolute;top:46px;right:10px;z-index:5;border:1px solid #2a3754;background:#121826;color:#cfe1ff;border-radius:999px;padding:6px 10px;cursor:pointer}
</style>
</head>
<body>
<div class="wrap">
  <aside>
    <h1>Wind-on-Wall — Live</h1>
    <div class="row">
      <input id="file" type="file" accept="video/*">
      <button id="webcam" class="btn">Webcam</button>
      <button id="play" class="btn secondary">Play/Pause</button>
    </div>
    <div class="row">
      <button id="replay" class="btn secondary">↺ Replay</button>
      <span class="small">Shortcut: <span class="kbd">R</span></span>
    </div>
    <div class="row small">Or URL: <span class="kbd">?src=clip.mp4</span> (same-origin or CORS)</div>

    <fieldset>
      <legend>Temporal window</legend>
      <div class="row"><label>Δt (seconds)</label><input id="dt" type="range" min="2" max="10" step="0.5" value="6"><span id="dtV">6.0</span></div>
      <div class="row"><label>Diff threshold</label><input id="thr" type="range" min="4" max="60" value="18"><span id="thrV">18</span></div>
      <div class="row"><label>Grey level</label><input id="grey" type="range" min="60" max="200" value="120"><span id="greyV">120</span></div>
      <div class="row"><label>Pre-blur (px)</label><input id="preblur" type="range" min="0" max="3" value="0"><span id="preblurV">0</span></div>
    </fieldset>

    <fieldset>
      <legend>Ghosts (motion)</legend>
      <div class="row"><label>Ghost opacity</label><input id="gAlpha" type="range" min="0" max="1" step="0.05" value="0.7"><span id="gAlphaV">0.70</span></div>
      <div class="row"><label>Blend mode</label>
        <select id="gBlend">
          <option value="normal">Normal</option>
          <option value="screen" selected>Screen</option>
          <option value="lighter">Lighter</option>
        </select>
      </div>
      <div class="row">
        <label>Use custom color</label>
        <input id="gUseColor" type="checkbox">
        <input id="gColor" type="color" value="#ffffff">
      </div>
    </fieldset>

    <fieldset>
      <legend>Stain (residual blotches)</legend>
      <div class="row"><label>Enable stain</label><input id="stainOn" type="checkbox" checked></div>
      <div class="row"><label>Decay</label><input id="decay" type="range" min="0.90" max="0.995" step="0.001" value="0.970"><span id="decayV">0.970</span></div>
      <div class="row"><label>Strength</label><input id="strength" type="range" min="0.1" max="1" step="0.05" value="0.50"><span id="strengthV">0.50</span></div>
      <div class="row"><label>Expand (px)</label><input id="expand" type="range" min="0" max="8" step="1" value="2"><span id="expandV">2</span></div>
      <div class="row"><label>Stain color</label><input id="sColor" type="color" value="#223b7a"></div>
    </fieldset>

    <fieldset>
      <legend>Recall / Linger / Edge</legend>
      <div class="row"><label>Recall on</label><input id="recallOn" type="checkbox"></div>
      <div class="row"><label>Recall prob</label><input id="recallProb" type="range" min="0" max="1" step="0.01" value="0.10"><span id="recallProbV">0.10</span></div>
      <div class="row"><label>Recall color</label><input id="recallColor" type="color" value="#00e7ff"></div>

      <div class="row"><label>Linger (s)</label><input id="recallLinger" type="range" min="0.2" max="3" step="0.1" value="1.2"><span id="recallLingerV">1.2</span></div>

      <div class="row"><label>Ghost edge</label><input id="ghostEdgeOn" type="checkbox"></div>
      <div class="row"><label>Ghost edge color</label><input id="ghostEdgeColor" type="color" value="#ffffff"><input id="ghostEdgeAlpha" type="range" min="0" max="1" step="0.05" value="0.8"><span id="ghostEdgeAlphaV">0.8</span></div>

      <div class="row"><label>Stain edge</label><input id="stainEdgeOn" type="checkbox"></div>
      <div class="row"><label>Stain edge color</label><input id="stainEdgeColor" type="color" value="#223b7a"><input id="stainEdgeAlpha" type="range" min="0" max="1" step="0.05" value="0.7"><span id="stainEdgeAlphaV">0.7</span></div>

      <div class="row"><label>Recall edge</label><input id="recallEdgeOn" type="checkbox"></div>
      <div class="row"><label>Recall edge color</label><input id="recallEdgeColor" type="color" value="#00e7ff"><input id="recallEdgeAlpha" type="range" min="0" max="1" step="0.05" value="0.7"><span id="recallEdgeAlphaV">0.7</span></div>

      <div class="row"><label>Linger edge</label><input id="lingerEdgeOn" type="checkbox"></div>
      <div class="row"><label>Linger edge color</label><input id="lingerEdgeColor" type="color" value="#ff00ff"><input id="lingerEdgeAlpha" type="range" min="0" max="1" step="0.05" value="0.8"><span id="lingerEdgeAlphaV">0.8</span></div>

      <div class="row"><label>Edge thr</label><input id="edgeThr" type="range" min="5" max="128" step="1" value="40"><span id="edgeThrV">40</span></div>
    </fieldset>

    <fieldset>
      <legend>Export</legend>
      <div class="row">
        <label>Format</label>
        <select id="format">
          <option value="mp4">MP4 (preferred)</option>
          <option value="webm">WebM</option>
          <option value="auto" selected>Auto (best available)</option>
        </select>
      </div>
      <div class="row">
        <button id="recStart" class="btn">Start Recording (preview)</button>
        <button id="recStop" class="btn" disabled>Stop & Save</button>
      </div>
      <div class="row">
        <button id="shot" class="btn secondary">Export PNG</button>
      </div>
      <div class="row">
        <button id="exportOne" class="btn">Export 1:1 (native)</button>
      </div>
      <div class="row small" id="supportNote"></div>
      <div class="row small" id="dbg">buffer: 0 | fps —</div>
    </fieldset>
  </aside>

  <main>
    <!-- live canvases -->
    <canvas id="stain"></canvas>
    <canvas id="ghost"></canvas>
    <canvas id="final"></canvas>

    <!-- these exist in your first script logic -->
    <canvas id="proc" style="display:none;"></canvas>
    <canvas id="maskCanvas" style="display:none;"></canvas>
    <canvas id="colCanvas" style="display:none;"></canvas>
    <canvas id="hauntCanvas" style="display:none;"></canvas>
    <canvas id="tintCanvas" style="display:none;"></canvas>
    <canvas id="recallCanvas" style="display:none;"></canvas>
    <canvas id="edgeCanvas" style="display:none;"></canvas>
    <canvas id="edgeLayerCanvas" style="display:none;"></canvas>

    <div id="hud" class="hud"></div>
    <div id="recHUD" class="rec" style="display:none;"><span class="dot"></span><span id="recTime">REC 00:00</span></div>
    <div id="nosrc" class="nosrc" style="display:none;">load a clip or use the webcam</div>
    <button id="replayFloat" class="fab" title="Replay (R)">↺</button>
  </main>
</div>

<script>
(function(){
  // ---------- Elements ----------
  const can = {
    stain: document.getElementById('stain'),
    ghost: document.getElementById('ghost'),
    final: document.getElementById('final'),
  };
  const sctx = can.stain.getContext('2d');
  const gctx = can.ghost.getContext('2d');
  const fctx = can.final.getContext('2d');

  // extra canvases from first script
  const proc            = document.getElementById('proc');
  const pctx            = proc.getContext('2d', {willReadFrequently:true});
  const maskCanvas      = document.getElementById('maskCanvas');
  const maskCtx         = maskCanvas.getContext('2d');
  const colCanvas       = document.getElementById('colCanvas');
  const colCtx          = colCanvas.getContext('2d');
  const hauntCanvas     = document.getElementById('hauntCanvas');
  const hauntCtx        = hauntCanvas.getContext('2d');
  const tintCanvas      = document.getElementById('tintCanvas');
  const tintCtx         = tintCanvas.getContext('2d');
  const recallCanvas    = document.getElementById('recallCanvas');
  const recallCtx       = recallCanvas.getContext('2d');
  const edgeCanvas      = document.getElementById('edgeCanvas');
  const edgeCtx         = edgeCanvas.getContext('2d');
  const edgeLayerCanvas = document.getElementById('edgeLayerCanvas');
  const edgeLayerCtx    = edgeLayerCanvas.getContext('2d');

  const file = document.getElementById('file');
  const webcamBtn = document.getElementById('webcam');
  const playBtn = document.getElementById('play');
  const replayBtn = document.getElementById('replay');
  const replayFloat = document.getElementById('replayFloat');
  const recStartBtn = document.getElementById('recStart');
  const recStopBtn  = document.getElementById('recStop');
  const shotBtn = document.getElementById('shot');
  const exportOneBtn = document.getElementById('exportOne');
  const hud = document.getElementById('hud');
  const recHUD = document.getElementById('recHUD');
  const recTime = document.getElementById('recTime');
  const dbg = document.getElementById('dbg');
  const supportNote = document.getElementById('supportNote');
  const nosrc = document.getElementById('nosrc');

  const ids = ["dt","thr","grey","preblur","gAlpha","decay","strength","expand","recallProb","recallLinger","ghostEdgeAlpha","stainEdgeAlpha","recallEdgeAlpha","lingerEdgeAlpha","edgeThr"];
  const el  = Object.fromEntries(ids.map(id=>[id, document.getElementById(id)]));
  const out = {
    dtV:document.getElementById('dtV'),
    thrV:document.getElementById('thrV'),
    greyV:document.getElementById('greyV'),
    preblurV:document.getElementById('preblurV'),
    gAlphaV:document.getElementById('gAlphaV'),
    decayV:document.getElementById('decayV'),
    strengthV:document.getElementById('strengthV'),
    expandV:document.getElementById('expandV'),
    recallProbV:document.getElementById('recallProbV'),
    recallLingerV:document.getElementById('recallLingerV'),
    ghostEdgeAlphaV:document.getElementById('ghostEdgeAlphaV'),
    stainEdgeAlphaV:document.getElementById('stainEdgeAlphaV'),
    recallEdgeAlphaV:document.getElementById('recallEdgeAlphaV'),
    lingerEdgeAlphaV:document.getElementById('lingerEdgeAlphaV'),
    edgeThrV:document.getElementById('edgeThrV')
  };

  const stainOn          = document.getElementById('stainOn');
  const sColor           = document.getElementById('sColor');
  const gBlend           = document.getElementById('gBlend');
  const formatSel        = document.getElementById('format');
  const gUseColor        = document.getElementById('gUseColor');
  const gColor           = document.getElementById('gColor');

  const recallOn         = document.getElementById('recallOn');
  const recallProb       = document.getElementById('recallProb');
  const recallColor      = document.getElementById('recallColor');
  const recallLinger     = document.getElementById('recallLinger');

  const ghostEdgeOn      = document.getElementById('ghostEdgeOn');
  const ghostEdgeColor   = document.getElementById('ghostEdgeColor');
  const ghostEdgeAlpha   = document.getElementById('ghostEdgeAlpha');

  const stainEdgeOn      = document.getElementById('stainEdgeOn');
  const stainEdgeColor   = document.getElementById('stainEdgeColor');
  const stainEdgeAlpha   = document.getElementById('stainEdgeAlpha');

  const recallEdgeOn     = document.getElementById('recallEdgeOn');
  const recallEdgeColor  = document.getElementById('recallEdgeColor');
  const recallEdgeAlpha  = document.getElementById('recallEdgeAlpha');

  const lingerEdgeOn     = document.getElementById('lingerEdgeOn');
  const lingerEdgeColor  = document.getElementById('lingerEdgeColor');
  const lingerEdgeAlpha  = document.getElementById('lingerEdgeAlpha');

  const edgeThr          = document.getElementById('edgeThr');

  function sync(){
    if(out.dtV) out.dtV.textContent             = (+el.dt.value).toFixed(1);
    if(out.thrV) out.thrV.textContent           = el.thr.value;
    if(out.greyV) out.greyV.textContent         = el.grey.value;
    if(out.preblurV) out.preblurV.textContent   = el.preblur.value;
    if(out.gAlphaV) out.gAlphaV.textContent     = (+el.gAlpha.value).toFixed(2);
    if(out.decayV) out.decayV.textContent       = (+el.decay.value).toFixed(3);
    if(out.strengthV) out.strengthV.textContent = (+el.strength.value).toFixed(2);
    if(out.expandV) out.expandV.textContent     = el.expand.value;
    if(out.recallProbV) out.recallProbV.textContent = (+el.recallProb.value).toFixed(2);
    if(out.recallLingerV) out.recallLingerV.textContent = (+el.recallLinger.value).toFixed(1);
    if(out.ghostEdgeAlphaV) out.ghostEdgeAlphaV.textContent = (+el.ghostEdgeAlpha.value).toFixed(2);
    if(out.stainEdgeAlphaV) out.stainEdgeAlphaV.textContent = (+el.stainEdgeAlpha.value).toFixed(2);
    if(out.recallEdgeAlphaV) out.recallEdgeAlphaV.textContent = (+el.recallEdgeAlpha.value).toFixed(2);
    if(out.lingerEdgeAlphaV) out.lingerEdgeAlphaV.textContent = (+el.lingerEdgeAlpha.value).toFixed(2);
    if(out.edgeThrV) out.edgeThrV.textContent = el.edgeThr.value;
  }
  [
    el.dt, el.thr, el.grey, el.preblur, el.gAlpha, el.decay, el.strength, el.expand,
    stainOn, sColor, gBlend, formatSel, gUseColor, gColor,
    recallOn, recallProb, recallColor, recallLinger,
    ghostEdgeOn, ghostEdgeColor, ghostEdgeAlpha,
    stainEdgeOn, stainEdgeColor, stainEdgeAlpha,
    recallEdgeOn, recallEdgeColor, recallEdgeAlpha,
    lingerEdgeOn, lingerEdgeColor, lingerEdgeAlpha,
    edgeThr
  ].forEach(x=> x && x.addEventListener('input', sync));
  sync();

  // ---------- Source ----------
  const vid = document.createElement('video');
  vid.crossOrigin = "anonymous";
  vid.playsInline = true; vid.muted = true; vid.loop = true; vid.preload = "auto";

  const qs = new URLSearchParams(location.search);
  const srcParam = qs.get('src'); if(srcParam){ vid.src = srcParam; }

  let mediaStream = null;
  file.addEventListener('change', e=>{
    const f = e.target.files[0]; if(!f) return;
    stopWebcam();
    resetState();
    vid.src = URL.createObjectURL(f);
    vid.play();
  });
  playBtn.addEventListener('click', ()=> vid.paused ? vid.play() : vid.pause());
  webcamBtn.addEventListener('click', ()=> startWebcam().catch(e=>alert('Webcam failed: '+e.message)));
  async function startWebcam(){
    stopWebcam();
    resetState();
    mediaStream = await navigator.mediaDevices.getUserMedia({video:true, audio:false});
    vid.srcObject = mediaStream; await vid.play();
  }
  function stopWebcam(){ if(mediaStream){ mediaStream.getTracks().forEach(t=>t.stop()); mediaStream=null; } }

  // ---------- HiDPI sizing (preview canvases) ----------
  function fit(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const r = can.final.getBoundingClientRect();
    const W = Math.max(2, Math.round(r.width*dpr));
    const H = Math.max(2, Math.round(r.height*dpr));
    [can.stain,can.ghost,can.final,proc,maskCanvas,colCanvas,hauntCanvas,tintCanvas,recallCanvas,edgeCanvas,edgeLayerCanvas].forEach(c=>{
      c.width=W; c.height=H;
    });
  }
  new ResizeObserver(fit).observe(can.final);
  fit();

  // ---------- Buffers (preview-res history for live view) ----------
  const buf = []; const MAX_SEC = 14;
  function pushFrame(img, t){
    buf.push({t, data: new Uint8ClampedArray(img.data), w: img.width, h: img.height});
    const cutoff = t - (MAX_SEC + 2);
    while(buf.length && buf[0].t < cutoff) buf.shift();
  }
  function getPastFrame(delta){
    const target = vid.currentTime - delta;
    for(let i=buf.length-1;i>=0;i--){ if(buf[i].t <= target) return buf[i]; }
    return buf[0] || null;
  }

  function drawVideoContained(ctx, video, W, H, blurPx){
    ctx.save();
    ctx.clearRect(0,0,W,H);
    if(blurPx>0) ctx.filter = `blur(${blurPx}px)`;
    const vw=video.videoWidth||0, vh=video.videoHeight||0;
    if(vw && vh){
      const s = Math.min(W/vw, H/vh);
      const dw = Math.round(vw*s), dh = Math.round(vh*s);
      const dx = Math.floor((W-dw)/2), dy = Math.floor((H-dh)/2);
      ctx.drawImage(video, dx,dy,dw,dh);
    }
    ctx.restore();
  }

  // ---------- Recording PREVIEW canvas ----------
  let recorder=null, chunks=[], recStartTime=0, recTimer=null, recMime="", recExt="webm";
  function bestSupported(){
    const mp4='video/mp4;codecs=avc1.42E01E,mp4a.40.2';
    const webm='video/webm;codecs=vp9,opus';
    const webm2='video/webm;codecs=vp8,opus';
    const canMp4 = !!(window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(mp4));
    const canWebm= !!(window.MediaRecorder && MediaRecorder.isTypeSupported && (MediaRecorder.isTypeSupported(webm)||MediaRecorder.isTypeSupported(webm2)));
    return {canMp4, canWebm, mp4, webm:(MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(webm)?webm:webm2)};
  }
  function refreshSupportNote(){
    const s=bestSupported();
    const fmt=formatSel.value;
    let msg='';
    if(fmt==='mp4'){ msg = s.canMp4 ? '<span class="ok">MP4 recording supported ✓</span>' : '<span class="warn">MP4 not supported here. Use Safari/WebKit or switch to WebM.</span>'; }
    else if(fmt==='webm'){ msg = s.canWebm ? 'WebM recording supported ✓' : '<span class="warn">WebM not supported.</span>'; }
    else { msg = s.canMp4 ? 'Auto → MP4' : (s.canWebm ? 'Auto → WebM' : '<span class="warn">Recording unsupported.</span>'); }
    supportNote.innerHTML = msg;
  }
  refreshSupportNote();
  formatSel.addEventListener('change', refreshSupportNote);

  function startRecording(){
    const s=bestSupported(); const sel=formatSel.value;
    let mime='';
    if(sel==='mp4') mime = s.canMp4 ? s.mp4 : '';
    else if(sel==='webm') mime = s.canWebm ? s.webm : '';
    else mime = s.canMp4 ? s.mp4 : (s.canWebm ? s.webm : '');
    if(!mime){ alert('Recording format not supported on this browser.'); return; }

    const stream = can.final.captureStream ? can.final.captureStream(30) : can.final.mozCaptureStream(30);
    chunks=[];
    recorder = new MediaRecorder(stream, {mimeType:mime, videoBitsPerSecond: 8_000_000});
    recMime=mime; recExt = mime.startsWith('video/mp4') ? 'mp4' : 'webm';
    recorder.ondataavailable = e=>{ if(e.data && e.data.size) chunks.push(e.data); };
    recorder.onstop = ()=>{
      const blob = new Blob(chunks, {type: recMime});
      const a = document.createElement('a');
      a.download = `wind_on_wall_${Date.now()}.${recExt}`;
      a.href = URL.createObjectURL(blob);
      a.click();
      stopRecUI();
    };
    recorder.start(250);

    recStartTime = performance.now();
    recTimer = setInterval(()=>{
      const t = Math.floor((performance.now()-recStartTime)/1000);
      const mm = String(Math.floor(t/60)).padStart(2,'0');
      const ss = String(t%60).padStart(2,'0');
      recTime.textContent = `REC ${mm}:${ss}`;
    },250);
    recHUD.style.display='flex';
    recStartBtn.disabled=true; recStopBtn.disabled=false;
  }
  function stopRecording(){ if(recorder && recorder.state==='recording'){ recorder.stop(); } }
  function stopRecUI(){ clearInterval(recTimer); recTimer=null; recHUD.style.display='none'; recStartBtn.disabled=false; recStopBtn.disabled=true; }
  recStartBtn.addEventListener('click', startRecording);
  recStopBtn.addEventListener('click',  stopRecording);

  shotBtn.addEventListener('click', ()=>{
    const a = document.createElement('a');
    a.download = 'still_'+Date.now()+'.png';
    a.href = can.final.toDataURL('image/png');
    a.click();
  });

  // ---------- Replay ----------
  function resetState(){
    buf.length = 0;
    sctx.clearRect(0,0,can.stain.width,can.stain.height);
    gctx.clearRect(0,0,can.ghost.width,can.ghost.height);
    hauntCtx.clearRect(0,0,hauntCanvas.width,hauntCanvas.height);
    tintCtx.clearRect(0,0,tintCanvas.width,tintCanvas.height);
    recallCtx.clearRect(0,0,recallCanvas.width,recallCanvas.height);
    edgeCtx.clearRect(0,0,edgeCanvas.width,edgeCanvas.height);
  }
  function replay(){
    if(vid.srcObject){
      alert('Replay is for file/URL clips. Stop Webcam and load a clip to use Replay.');
      return;
    }
    if(!vid.currentSrc && !vid.src){ alert('No clip loaded.'); return; }
    if(recorder && recorder.state==='recording'){ stopRecording(); }
    try{
      vid.pause();
      resetState();
      const onSeeked = () => { vid.removeEventListener('seeked', onSeeked); vid.play(); };
      vid.addEventListener('seeked', onSeeked, { once:true });
      vid.currentTime = 0;
    }catch(e){
      const src = vid.currentSrc || vid.src;
      if(src){ resetState(); vid.src = src; vid.play(); }
    }
  }
  replayBtn.addEventListener('click', replay);
  replayFloat.addEventListener('click', replay);
  document.addEventListener('keydown', (e)=>{
    const t = e.target;
    if(t && (t.tagName==='INPUT' || t.tagName==='SELECT' || t.tagName==='TEXTAREA' || t.isContentEditable)) return;
    if(e.code === 'KeyR'){ e.preventDefault(); replay(); }
    else if(e.code === 'Space'){ e.preventDefault(); vid.paused ? vid.play() : vid.pause(); }
  });

  // ---------- Helpers from first script that we assume exist ----------
  // snapshotGhost(time): stores ghost frame for recall bursts
  // startRandomBurst(): triggers recall burst & returns burst object {frames:[], i:0}
  // drawTinted(ctx, frameImgData, colorHex): draws burst frame tinted to ctx
  // exportDecayStep(): in original script it decays recallCanvas; we reimplement per-export version later

  function hexToRgb(hex){
    const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return m ? [parseInt(m[1],16), parseInt(m[2],16), parseInt(m[3],16)] : [255,255,255];
  }

  // ---------- Main PREVIEW loop (unchanged behavior) ----------
  let lastT=0, fpsEMA=0;
  requestAnimationFrame(function tick(now){
    requestAnimationFrame(tick);

    const W = can.final.width, H = can.final.height;

    // base fill
    const grey=+el.grey.value;
    fctx.clearRect(0,0,W,H);
    fctx.fillStyle=`rgb(${grey},${grey},${grey})`;
    fctx.fillRect(0,0,W,H);

    if(vid.readyState < 2){
      nosrc.style.display = 'block';
      return;
    } else {
      nosrc.style.display = 'none';
    }

    // === processOneFrame() inline ===
    // draw video into proc (contained for preview)
    pctx.clearRect(0,0,W,H);
    drawVideoContained(pctx, vid, W, H, +el.preblur.value);

    // current pixels
    const curr = pctx.getImageData(0,0,W,H);
    pushFrame(curr, vid.currentTime);

    // past frame
    const past = getPastFrame(+el.dt.value);

    // motion diff, ghost, stain
    if(past){
      const c=curr.data, p=past.data;
      const ghostImg=gctx.createImageData(W,H);
      const gd=ghostImg.data;
      const thr=+el.thr.value;
      const mask=new Uint8ClampedArray(W*H);
      let changedCount=0;

      for(let i=0,j=0;i<c.length;i+=4,j++){
        const r=c[i], g=c[i+1], b=c[i+2];
        const pr=p[i],pg=p[i+1],pb=p[i+2];
        const lc=r*0.2126+g*0.7152+b*0.0722;
        const lp=pr*0.2126+pg*0.7152+pb*0.0722;
        const d=Math.abs(lc-lp);

        if(d>thr){
          changedCount++; mask[j]=255;
          if(gUseColor.checked){
            const [cr,cg,cb]=hexToRgb(gColor.value);
            const a=Math.max(40,Math.min(255,(d-thr)*8));
            gd[i]=cr; gd[i+1]=cg; gd[i+2]=cb; gd[i+3]=a;
          } else {
            gd[i]=(r+(255-pr))*0.5;
            gd[i+1]=(g+(255-pg))*0.5;
            gd[i+2]=(b+(255-pb))*0.5;
            gd[i+3]=255;
          }
        } else {
          gd[i]=gd[i+1]=gd[i+2]=0; gd[i+3]=0;
        }
      }
      gctx.putImageData(ghostImg,0,0);

      // stain accumulation
      if(stainOn.checked){
        const decay=+el.decay.value;
        sctx.globalCompositeOperation='destination-out';
        sctx.fillStyle=`rgba(0,0,0,${1-decay})`;
        sctx.fillRect(0,0,W,H);
        sctx.globalCompositeOperation='source-over';

        const mImg=maskCtx.createImageData(W,H);
        const mdat=mImg.data;
        for(let j=0,k=0;j<mask.length;j++,k+=4){
          const v=mask[j]; mdat[k]=mdat[k+1]=mdat[k+2]=v; mdat[k+3]=v;
        }
        maskCtx.putImageData(mImg,0,0);

        colCtx.clearRect(0,0,W,H);
        const expand=+el.expand.value;
        if(expand>0){ colCtx.filter=`blur(${expand}px)`; }
        colCtx.drawImage(maskCanvas,0,0);
        colCtx.filter='none';
        colCtx.globalCompositeOperation='source-in';
        colCtx.fillStyle=sColor.value;
        colCtx.globalAlpha=+el.strength.value;
        colCtx.fillRect(0,0,W,H);
        colCtx.globalCompositeOperation='source-over';
        colCtx.globalAlpha=1;
        sctx.drawImage(colCanvas,0,0);
      }
    }

    // recall decay step for preview
    (function previewDecayStep(){
      const lingerS=Math.max(0.2,+recallLinger.value||1.2);
      const fade=1-Math.exp(-1/(lingerS*30));
      recallCtx.globalCompositeOperation='destination-out';
      recallCtx.fillStyle=`rgba(0,0,0,${fade})`;
      recallCtx.fillRect(0,0,recallCanvas.width,recallCanvas.height);
      recallCtx.globalCompositeOperation='source-over';
    })();

    // snapshotGhost + recall bursts
    if(vid && !isNaN(vid.currentTime)) snapshotGhost(vid.currentTime);
    if(recallOn && recallOn.checked){
      const prob=+recallProb.value||0;
      // startRandomBurst handles setting global activeBurst for preview
      if(Math.random()<prob && !window.activeBurst){
        startRandomBurst();
      }
    }
    if(window.activeBurst && window.activeBurst.frames && window.activeBurst.frames.length){
      const color=recallColor?recallColor.value:'#00e7ff';
      drawTinted(recallCtx, window.activeBurst.frames[window.activeBurst.i], color);
      window.activeBurst.i++;
      if(window.activeBurst.i>=window.activeBurst.frames.length) window.activeBurst=null;
    }

    // fade linger layer for hauntCanvas / tintCanvas etc is assumed handled elsewhere in your OG loop;
    // we assume hauntCanvas/tintCanvas already contain what you want.

    // outlines
    edgeCtx.clearRect(0,0,edgeCanvas.width,edgeCanvas.height);
    (function doOutlines(){
      const TH = (+edgeThr.value | 0) || 40;
      const TL = Math.max(0, Math.floor(TH * 0.5));
      function rgbaFrom(hex, a01){
        const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex||'#000000');
        return [parseInt(m[1],16), parseInt(m[2],16), parseInt(m[3],16), Math.max(0,Math.min(1,a01||1))];
      }
      function drawOutlineFrom(srcCanvas, colorHex, alpha01){
        const W = srcCanvas.width, H = srcCanvas.height; if(!W||!H) return;
        const sctxL = srcCanvas.getContext('2d');
        const img  = sctxL.getImageData(0,0,W,H);
        const d    = img.data;
        const L = new Uint8ClampedArray(W*H);
        for (let i=0,j=0;i<d.length;i+=4,++j){
          const lum = d[i]*0.2126 + d[i+1]*0.7152 + d[i+2]*0.0722;
          const a   = d[i+3];
          L[j] = Math.max(lum, a);
        }
        const E = new Uint8ClampedArray(W*H);
        for (let y=1;y<H-1;y++){
          let idx=y*W+1;
          for (let x=1;x<W-1;x++,idx++){
            const a=L[idx-W-1], b=L[idx-W], c=L[idx-W+1];
            const d0=L[idx-1],              f=L[idx+1];
            const g=L[idx+W-1], h=L[idx+W], i=L[idx+W+1];
            const gx = -a -2*b -c + g +2*h + i;
            const gy = -a -2*d0 -g + c +2*f + i;
            const mag = Math.abs(gx) + Math.abs(gy);
            let aa; if(mag>=TH) aa=255; else if(mag<=TL) aa=0; else aa=Math.round((mag-TL)/(TH-TL)*255);
            E[idx]=aa;
          }
        }
        for (let q=0,j=0;q<d.length;q+=4,++j){ E[j] = Math.round(E[j] * (d[q+3]/255)); }
        edgeLayerCtx.clearRect(0,0,edgeLayerCanvas.width,edgeLayerCanvas.height);
        const [r,g,b,a01] = rgbaFrom(colorHex, alpha01);
        const mask = edgeLayerCtx.createImageData(W,H);
        const md = mask.data;
        for (let j=0,p=0;j<E.length;j++,p+=4){
          const a = E[j]; if(!a){ md[p]=md[p+1]=md[p+2]=md[p+3]=0; continue; }
          md[p]=r; md[p+1]=g; md[p+2]=b; md[p+3]=Math.min(255, Math.round(a*a01));
        }
        edgeLayerCtx.putImageData(mask,0,0);
        edgeCtx.globalCompositeOperation='source-over';
        edgeCtx.drawImage(edgeLayerCanvas,0,0);
      }

      if (ghostEdgeOn && ghostEdgeOn.checked)   drawOutlineFrom(can.ghost,    ghostEdgeColor.value,  +ghostEdgeAlpha.value||0.8);
      if (stainEdgeOn && stainEdgeOn.checked)   drawOutlineFrom(can.stain,    stainEdgeColor.value,  +stainEdgeAlpha.value||0.7);
      if (recallEdgeOn && recallEdgeOn.checked) drawOutlineFrom(recallCanvas, recallEdgeColor.value, +recallEdgeAlpha.value||0.7);
      if (lingerEdgeOn && lingerEdgeOn.checked) drawOutlineFrom(hauntCanvas,  lingerEdgeColor.value, +lingerEdgeAlpha.value||0.8);
    })();

    // compose final preview frame
    if(stainOn.checked){
      fctx.globalCompositeOperation='multiply';
      fctx.drawImage(can.stain,0,0);
      fctx.globalCompositeOperation='source-over';
    }
    fctx.globalAlpha=+el.gAlpha.value;
    fctx.globalCompositeOperation=gBlend.value;
    fctx.drawImage(can.ghost,0,0);
    fctx.globalAlpha=1;
    fctx.globalCompositeOperation='source-over';

    // recall (screen)
    fctx.globalCompositeOperation='screen';
    fctx.drawImage(recallCanvas,0,0);
    // linger + tint
    fctx.drawImage(tintCanvas,0,0);
    fctx.drawImage(hauntCanvas,0,0);
    fctx.globalCompositeOperation='source-over';

    // edges
    fctx.drawImage(edgeCanvas,0,0);

    // HUD
    const dt = now - lastT; lastT = now;
    const inst = dt>0 ? 1000/dt : 0; fpsEMA = fpsEMA? fpsEMA*0.9 + inst*0.1 : inst;
    hud.textContent = `Δt = ${(+el.dt.value).toFixed(1)} s
thr = ${el.thr.value}, pre-blur = ${el.preblur.value}, grey = ${el.grey.value}
ghost: ${gBlend.value}, α=${(+el.gAlpha.value).toFixed(2)}${gUseColor.checked?`, color=${gColor.value}`:''}
stain: decay=${(+el.decay.value).toFixed(3)}, expand=${el.expand.value}, strength=${(+el.strength.value).toFixed(2)}
changed ~ live`;

    const sSup = bestSupported();
    dbg.textContent = `buffer: ${buf.length} | fps ~ ${fpsEMA.toFixed(1)} | support: ${sSup.canMp4?'MP4✓':'MP4×'}/${sSup.canWebm?'WebM✓':'WebM×'}`;
  });

  vid.addEventListener('loadeddata', ()=>{ vid.play().catch(()=>{}); });

  // ---------- FIXED 1:1 EXPORT IMPLEMENTATION ----------
  exportOneBtn.addEventListener('click', exportSourceOnce);

  async function exportSourceOnce(){
    // reject webcam
    if (vid.srcObject){
      alert('1:1 export is for file/URL clips, not webcam.');
      return;
    }
    if(!(vid.currentSrc || vid.src)){
      alert('Load a clip first.');
      return;
    }

    if(vid.readyState < 1){
      await new Promise(res=>vid.addEventListener('loadedmetadata',res,{once:true}));
    }
    const vw=vid.videoWidth|0, vh=vid.videoHeight|0;
    if(!vw||!vh){
      alert('Video metadata unavailable.');
      return;
    }

    const s=bestSupported(); let mime='',ext='webm';
    if(s.canMp4){ mime=s.mp4; ext='mp4'; }
    else if(s.canWebm){ mime=s.webm; ext='webm'; }
    else { alert('Export not supported on this browser. Try Safari (MP4) or Chrome/Firefox (WebM).'); return; }

    exportOneBtn.disabled=true; recStartBtn.disabled=true;

    // snapshot state
    const prevState={ loop:vid.loop, rate:vid.playbackRate, paused:vid.paused, t:vid.currentTime };
    vid.pause(); vid.loop=false; vid.playbackRate=1;

    // OFFSCREEN HI-RES PIPELINE
    const hi = {
      final: document.createElement('canvas'),
      stain: document.createElement('canvas'),
      ghost: document.createElement('canvas'),
      work:  document.createElement('canvas'),
      mask:  document.createElement('canvas'),
      col:   document.createElement('canvas'),
      haunt: document.createElement('canvas'),
      tint:  document.createElement('canvas'),
      recall:document.createElement('canvas'),
      edge:  document.createElement('canvas'),
      edgeLayer: document.createElement('canvas')
    };
    for(const k in hi){ hi[k].width=vw; hi[k].height=vh; }

    const hfctx  = hi.final.getContext('2d');
    const hsctx  = hi.stain.getContext('2d');
    const hgctx  = hi.ghost.getContext('2d');
    const hpctx  = hi.work.getContext('2d',{willReadFrequently:true});
    const hMask  = hi.mask.getContext('2d');
    const hCol   = hi.col.getContext('2d');
    const hHaunt = hi.haunt.getContext('2d');
    const hTint  = hi.tint.getContext('2d');
    const hRecall= hi.recall.getContext('2d');
    const hEdge  = hi.edge.getContext('2d');
    const hEdgeL = hi.edgeLayer.getContext('2d');

    // local recall burst state for export
    let hiActiveBurst = null;

    function hiExportDecayStep(){
      const lingerS = Math.max(0.2, +recallLinger.value||1.2);
      const fade = 1-Math.exp(-1/(lingerS*30));
      hRecall.globalCompositeOperation='destination-out';
      hRecall.fillStyle=`rgba(0,0,0,${fade})`;
      hRecall.fillRect(0,0,hi.recall.width,hi.recall.height);
      hRecall.globalCompositeOperation='source-over';
    }

    const hiBuf=[]; const HI_MAX_SEC=14;
    function hiPushFrame(img,t){
      hiBuf.push({t, data:new Uint8ClampedArray(img.data), w:img.width, h:img.height});
      const cutoff=t-(HI_MAX_SEC+2);
      while(hiBuf.length && hiBuf[0].t<cutoff) hiBuf.shift();
    }
    function hiGetPastFrame(delta, nowT){
      const target=nowT-delta;
      for(let i=hiBuf.length-1;i>=0;i--){ if(hiBuf[i].t<=target) return hiBuf[i]; }
      return hiBuf[0]||null;
    }

    function rgbaFrom(hex, a01){
      const m=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex||'#000000');
      return [
        parseInt(m[1],16),
        parseInt(m[2],16),
        parseInt(m[3],16),
        Math.max(0,Math.min(1,a01||1))
      ];
    }

    function drawOutlineFrom(srcCanvas, colorHex, alpha01){
      const W=srcCanvas.width, H=srcCanvas.height; if(!W||!H) return;
      const sctxLocal=srcCanvas.getContext('2d');
      const img=sctxLocal.getImageData(0,0,W,H);
      const d=img.data;
      const L=new Uint8ClampedArray(W*H);
      for(let i=0,j=0;i<d.length;i+=4,++j){
        const lum=d[i]*0.2126+d[i+1]*0.7152+d[i+2]*0.0722;
        const a=d[i+3];
        L[j]=Math.max(lum,a);
      }
      const E=new Uint8ClampedArray(W*H);
      const TH=(+edgeThr.value|0)||40;
      const TL=Math.max(0,Math.floor(TH*0.5));
      for(let y=1;y<H-1;y++){
        let idx=y*W+1;
        for(let x=1;x<W-1;x++,idx++){
          const a=L[idx-W-1], b=L[idx-W], c=L[idx-W+1];
          const d0=L[idx-1],              f=L[idx+1];
          const g=L[idx+W-1], h=L[idx+W], i=L[idx+W+1];
          const gx=-a -2*b -c + g +2*h + i;
          const gy=-a -2*d0 -g + c +2*f + i;
          const mag=Math.abs(gx)+Math.abs(gy);
          let aa; if(mag>=TH) aa=255; else if(mag<=TL) aa=0; else aa=Math.round((mag-TL)/(TH-TL)*255);
          E[idx]=aa;
        }
      }
      for(let k=0,j2=0;k<d.length;k+=4,++j2){ E[j2]=Math.round(E[j2]*(d[k+3]/255)); }

      hEdgeL.clearRect(0,0,hi.edgeLayer.width,hi.edgeLayer.height);
      const [r,g,b,a01]=rgbaFrom(colorHex, alpha01);
      const mask=hEdgeL.createImageData(W,H);
      const md=mask.data;
      for(let j3=0,p=0;j3<E.length;j3++,p+=4){
        const a=E[j3];
        if(!a){ md[p]=md[p+1]=md[p+2]=md[p+3]=0; continue; }
        md[p]=r; md[p+1]=g; md[p+2]=b; md[p+3]=Math.min(255,Math.round(a*a01));
      }
      hEdgeL.putImageData(mask,0,0);
      hEdge.globalCompositeOperation='source-over';
      hEdge.drawImage(hi.edgeLayer,0,0);
    }

    function renderHiFrame(){
      const W=vw,H=vh;

      // base grey
      const grey=+el.grey.value;
      hfctx.clearRect(0,0,W,H);
      hfctx.fillStyle=`rgb(${grey},${grey},${grey})`;
      hfctx.fillRect(0,0,W,H);

      if(vid.readyState<2) return;

      // draw video full-bleed native res
      hpctx.clearRect(0,0,W,H);
      hpctx.drawImage(vid,0,0,W,H);
      const curr=hpctx.getImageData(0,0,W,H);
      const nowT=vid.currentTime;
      hiPushFrame(curr,nowT);

      const past=hiGetPastFrame(+el.dt.value, nowT);

      hgctx.clearRect(0,0,W,H);
      hEdge.clearRect(0,0,W,H);

      if(past){
        const c=curr.data, p=past.data;
        const ghostImg=hgctx.createImageData(W,H);
        const gd=ghostImg.data;
        const thr=+el.thr.value;
        const maskArr=new Uint8ClampedArray(W*H);

        for(let i=0,j=0;i<c.length;i+=4,j++){
          const r=c[i], g=c[i+1], b=c[i+2];
          const pr=p[i],pg=p[i+1],pb=p[i+2];
          const lc=r*0.2126+g*0.7152+b*0.0722;
          const lp=pr*0.2126+pg*0.7152+pb*0.0722;
          const d=Math.abs(lc-lp);

          if(d>thr){
            maskArr[j]=255;
            if(gUseColor.checked){
              const m=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(gColor.value);
              const cr=m?parseInt(m[1],16):255;
              const cg=m?parseInt(m[2],16):255;
              const cb=m?parseInt(m[3],16):255;
              const a=Math.max(40,Math.min(255,(d-thr)*8));
              gd[i]=cr; gd[i+1]=cg; gd[i+2]=cb; gd[i+3]=a;
            }else{
              gd[i]=(r+(255-pr))*0.5;
              gd[i+1]=(g+(255-pg))*0.5;
              gd[i+2]=(b+(255-pb))*0.5;
              gd[i+3]=255;
            }
          }else{
            gd[i]=gd[i+1]=gd[i+2]=0; gd[i+3]=0;
          }
        }
        hgctx.putImageData(ghostImg,0,0);

        // stain accumulate
        if(stainOn.checked){
          const decay=+el.decay.value;
          hsctx.globalCompositeOperation='destination-out';
          hsctx.fillStyle=`rgba(0,0,0,${1-decay})`;
          hsctx.fillRect(0,0,W,H);
          hsctx.globalCompositeOperation='source-over';

          const mImg=hMask.createImageData(W,H);
          const mdat=mImg.data;
          for(let j=0,k=0;j<maskArr.length;j++,k+=4){
            const v=maskArr[j];
            mdat[k]=mdat[k+1]=mdat[k+2]=v;
            mdat[k+3]=v;
          }
          hMask.putImageData(mImg,0,0);

          hCol.clearRect(0,0,W,H);
          const expand=+el.expand.value;
          if(expand>0){ hCol.filter=`blur(${expand}px)`; }
          hCol.drawImage(hi.mask,0,0);
          hCol.filter='none';
          hCol.globalCompositeOperation='source-in';
          hCol.fillStyle=sColor.value;
          hCol.globalAlpha=+el.strength.value;
          hCol.fillRect(0,0,W,H);
          hCol.globalCompositeOperation='source-over';
          hCol.globalAlpha=1;

          hsctx.drawImage(hi.col,0,0);
        }
      }

      // snapshotGhost for burst timing
      if(vid && !isNaN(vid.currentTime)){
        try{ snapshotGhost(vid.currentTime); }catch(_){}
      }

      // recall layer decay for export
      hiExportDecayStep();

      // possibly start a new burst
      if(recallOn && recallOn.checked){
        const prob=+recallProb.value||0;
        if(Math.random()<prob && !hiActiveBurst){
          try {
            const tmp = startRandomBurst(); // assume returns burst object
            if(tmp && tmp.frames && tmp.frames.length){
              hiActiveBurst={frames:tmp.frames.slice(), i:0};
            }
          }catch(_){}
        }
      }

      // advance burst
      if(hiActiveBurst && hiActiveBurst.frames && hiActiveBurst.frames.length){
        try{
          const color=recallColor?recallColor.value:'#00e7ff';
          drawTinted(hRecall, hiActiveBurst.frames[hiActiveBurst.i], color);
        }catch(_){}
        hiActiveBurst.i++;
        if(hiActiveBurst.i>=hiActiveBurst.frames.length){
          hiActiveBurst=null;
        }
      }

      // NOTE: we don't explicitly simulate haunt/tint evolution here; we just draw
      // their current buffers each frame. If in your actual runtime you accumulate
      // into hauntCanvas/tintCanvas each frame, you'd also mirror that logic here
      // into hHaunt/hTint. For now we'll assume they're mostly effects captured
      // through recall/ghost, so we leave them blank black each frame:
      hHaunt.clearRect(0,0,W,H);
      hTint.clearRect(0,0,W,H);

      // compose final @ native res
      if(stainOn.checked){
        hfctx.globalCompositeOperation='multiply';
        hfctx.drawImage(hi.stain,0,0);
        hfctx.globalCompositeOperation='source-over';
      }
      hfctx.globalAlpha=+el.gAlpha.value;
      hfctx.globalCompositeOperation=gBlend.value;
      hfctx.drawImage(hi.ghost,0,0);
      hfctx.globalAlpha=1;
      hfctx.globalCompositeOperation='source-over';

      hfctx.globalCompositeOperation='screen';
      hfctx.drawImage(hi.recall,0,0);
      hfctx.drawImage(hi.tint,0,0);
      hfctx.drawImage(hi.haunt,0,0);
      hfctx.globalCompositeOperation='source-over';

      // edges
      hEdge.clearRect(0,0,W,H);
      if (ghostEdgeOn && ghostEdgeOn.checked)   drawOutlineFrom(hi.ghost,    ghostEdgeColor.value,  +ghostEdgeAlpha.value||0.8);
      if (stainEdgeOn && stainEdgeOn.checked)   drawOutlineFrom(hi.stain,    stainEdgeColor.value,  +stainEdgeAlpha.value||0.7);
      if (recallEdgeOn && recallEdgeOn.checked) drawOutlineFrom(hi.recall,   recallEdgeColor.value, +recallEdgeAlpha.value||0.7);
      if (lingerEdgeOn && lingerEdgeOn.checked) drawOutlineFrom(hi.haunt,    lingerEdgeColor.value, +lingerEdgeAlpha.value||0.8);

      hfctx.drawImage(hi.edge,0,0);
    }

    // recorder on hi.final
    const expChunks=[];
    const stream = hi.final.captureStream ? hi.final.captureStream(30) : hi.final.mozCaptureStream(30);
    const expRecorder=new MediaRecorder(stream,{mimeType:mime,videoBitsPerSecond:12_000_000});
    expRecorder.ondataavailable=e=>{ if(e.data && e.data.size) expChunks.push(e.data); };
    const recDone=new Promise(resolve=>{ expRecorder.onstop=resolve; });

    let running=true;
    function hiLoop(){
      if(!running) return;
      renderHiFrame();
      requestAnimationFrame(hiLoop);
    }

    async function resetClipToZeroAndPlay(){
      return new Promise(ok=>{
        function afterSeek(){
          vid.removeEventListener('seeked', afterSeek);
          vid.play().catch(()=>{});
          ok();
        }
        const onData=()=>{
          vid.removeEventListener('loadeddata', onData);
          vid.addEventListener('seeked', afterSeek, {once:true});
          try{ vid.currentTime=0; }catch(_){ afterSeek(); }
        };
        if(vid.readyState>=2){ onData(); }
        else { vid.addEventListener('loadeddata', onData, {once:true}); }
      });
    }

    await resetClipToZeroAndPlay();
    expRecorder.start(250);
    hiLoop();

    const safetyMs=(isFinite(vid.duration)?vid.duration:60)*1000+5000;
    const safetyTimer=setTimeout(()=>finalize(), safetyMs);
    vid.addEventListener('ended', finalize, {once:true});

    function finalize(){
      clearTimeout(safetyTimer);
      running=false;
      try{expRecorder.stop();}catch(_){}
    }

    await recDone;

    const blob=new Blob(expChunks,{type:mime});
    const a=document.createElement('a');
    a.download=`wind_on_wall_1x_${vw}x${vh}_${Date.now()}.${ext}`;
    a.href=URL.createObjectURL(blob);
    a.click();

    vid.loop=prevState.loop;
    vid.playbackRate=prevState.rate;
    try{ vid.currentTime=prevState.t; }catch(_){}
    if(!prevState.paused){
      try{ await vid.play(); }catch(_){}
    }

    exportOneBtn.disabled=false;
    recStartBtn.disabled=false;
  }

})(); // IIFE
</script>
</body>
</html>
