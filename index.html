<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Wind-on-Wall — Ghosts + Stain (hi-res)</title>
<style>
  :root{
    --bg:#0b0e12;
    --fg:#e6eeff;
    --mut:#90a1bb;
    --accent:#ff5b5b
  }
  html,body{
    height:100%;margin:0;
    background:var(--bg);color:var(--fg);
    font:14px/1.35 system-ui,Segoe UI,Roboto,Helvetica,Arial
  }
  .wrap{
    display:grid;
    grid-template-columns:380px 1fr;
    gap:14px;
    height:100%
  }
  aside{
    padding:14px 12px 16px;
    border-right:1px solid #1a2233;
    overflow:auto
  }
  main{position:relative}
  canvas{
    position:absolute;
    inset:0;
    width:100%;
    height:100%;
    object-fit:contain;
    background:#000
  }
  h1{font-size:16px;margin:0 0 10px}
  fieldset{
    border:1px solid #1a2233;
    border-radius:10px;
    margin:10px 0;
    padding:10px
  }
  legend{
    padding:0 6px;
    color:#9fb7e8
  }
  .row{
    display:flex;
    align-items:center;
    gap:8px;
    margin:8px 0;
    flex-wrap:wrap
  }
  .row label{
    flex:1;
    color:var(--mut)
  }
  .row input[type="range"],
  .row select{
    flex:2
  }
  .btn{
    appearance:none;
    border:1px solid #2a3754;
    background:#121826;
    color:#cfe1ff;
    border-radius:8px;
    padding:6px 10px;
    cursor:pointer
  }
  .btn.secondary{
    background:#0e1422;
    border-color:#1f2b44;
    color:#a8b7d6
  }
  .btn:disabled{
    opacity:.5;
    cursor:not-allowed
  }
  .kbd{
    font:12px ui-monospace;
    background:#121520;
    border:1px solid #1f2736;
    border-radius:6px;
    padding:1px 6px;
    color:#b8c7e8
  }
  .small{
    font-size:12px;
    color:#93a6c4
  }
  .hud{
    position:absolute;
    top:10px;
    left:10px;
    background:rgba(0,0,0,.45);
    padding:6px 8px;
    border-radius:8px;
    font:12px ui-monospace;
    white-space:pre
  }
  .rec{
    position:absolute;
    top:10px;
    right:10px;
    background:rgba(0,0,0,.55);
    padding:6px 10px;
    border-radius:999px;
    font:12px ui-monospace;
    display:flex;
    align-items:center;
    gap:8px
  }
  .dot{
    width:8px;
    height:8px;
    background:var(--accent);
    border-radius:50%;
    box-shadow:0 0 8px var(--accent)
  }
  .warn{color:#ffb86b}
  .ok{color:#6be77a}
  .nosrc{
    position:absolute;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    color:#aac;
    font:12px ui-monospace;
    pointer-events:none
  }
  .fab{
    position:absolute;
    top:46px;
    right:10px;
    z-index:5;
    border:1px solid #2a3754;
    background:#121826;
    color:#cfe1ff;
    border-radius:999px;
    padding:6px 10px;
    cursor:pointer
  }
</style>
</head>
<body>
<div class="wrap">
  <aside>
    <h1>Wind-on-Wall — Live</h1>

    <div class="row">
      <input id="file" type="file" accept="video/*">
      <button id="webcam" class="btn">Webcam</button>
      <button id="play" class="btn secondary">Play/Pause</button>
    </div>

    <div class="row">
      <button id="replay" class="btn secondary">↺ Replay</button>
      <span class="small">Shortcut: <span class="kbd">R</span></span>
    </div>

    <div class="row small">Or URL: <span class="kbd">?src=clip.mp4</span> (same-origin or CORS)</div>

    <fieldset>
      <legend>Temporal window</legend>
      <div class="row">
        <label>Δt (seconds)</label>
        <input id="dt" type="range" min="2" max="10" step="0.5" value="6">
        <span id="dtV">6.0</span>
      </div>
      <div class="row">
        <label>Diff threshold</label>
        <input id="thr" type="range" min="4" max="60" value="18">
        <span id="thrV">18</span>
      </div>
      <div class="row">
        <label>Grey level</label>
        <input id="grey" type="range" min="60" max="200" value="120">
        <span id="greyV">120</span>
      </div>
      <div class="row">
        <label>Pre-blur (px)</label>
        <input id="preblur" type="range" min="0" max="3" value="0">
        <span id="preblurV">0</span>
      </div>
    </fieldset>

    <fieldset>
      <legend>Ghosts (motion)</legend>
      <div class="row">
        <label>Ghost opacity</label>
        <input id="gAlpha" type="range" min="0" max="1" step="0.05" value="0.7">
        <span id="gAlphaV">0.70</span>
      </div>
      <div class="row">
        <label>Blend mode</label>
        <select id="gBlend">
          <option value="normal">Normal</option>
          <option value="screen" selected>Screen</option>
          <option value="lighter">Lighter</option>
        </select>
      </div>
      <div class="row">
        <label>Use custom color</label>
        <input id="gUseColor" type="checkbox">
        <input id="gColor" type="color" value="#ffffff">
      </div>
    </fieldset>

    <fieldset>
      <legend>Stain (residual blotches)</legend>
      <div class="row">
        <label>Enable stain</label>
        <input id="stainOn" type="checkbox" checked>
      </div>
      <div class="row">
        <label>Decay</label>
        <input id="decay" type="range" min="0.90" max="0.995" step="0.001" value="0.970">
        <span id="decayV">0.970</span>
      </div>
      <div class="row">
        <label>Strength</label>
        <input id="strength" type="range" min="0.1" max="1" step="0.05" value="0.50">
        <span id="strengthV">0.50</span>
      </div>
      <div class="row">
        <label>Expand (px)</label>
        <input id="expand" type="range" min="0" max="8" step="1" value="2">
        <span id="expandV">2</span>
      </div>
      <div class="row">
        <label>Stain color</label>
        <input id="sColor" type="color" value="#223b7a">
      </div>
    </fieldset>

    <fieldset>
      <legend>Export</legend>
      <div class="row">
        <label>Format</label>
        <select id="format">
          <option value="mp4">MP4 (preferred)</option>
          <option value="webm">WebM</option>
          <option value="auto" selected>Auto (best available)</option>
        </select>
      </div>
      <div class="row">
        <button id="recStart" class="btn">Start Recording (preview)</button>
        <button id="recStop" class="btn" disabled>Stop & Save</button>
      </div>
      <div class="row">
        <button id="shot" class="btn secondary">Export PNG</button>
      </div>

      <div class="row">
        <button id="exportOne" class="btn">Export 1:1 (native)</button>
      </div>

      <div class="row small" id="supportNote"></div>
      <div class="row small" id="dbg">buffer: 0 | fps —</div>
    </fieldset>
  </aside>

  <main>
    <canvas id="stain"></canvas>
    <canvas id="ghost"></canvas>
    <canvas id="final"></canvas>
    <div id="hud" class="hud"></div>
    <div id="recHUD" class="rec" style="display:none;">
      <span class="dot"></span><span id="recTime">REC 00:00</span>
    </div>
    <div id="nosrc" class="nosrc" style="display:none;">load a clip or use the webcam</div>
    <button id="replayFloat" class="fab" title="Replay (R)">↺</button>
  </main>
</div>

<script>
(function(){
  // ---------- Elements ----------
  const can = {
    stain: document.getElementById('stain'),
    ghost: document.getElementById('ghost'),
    final: document.getElementById('final'),
  };
  const sctx = can.stain.getContext('2d');
  const gctx = can.ghost.getContext('2d');
  const fctx = can.final.getContext('2d');

  const file = document.getElementById('file');
  const webcamBtn = document.getElementById('webcam');
  const playBtn = document.getElementById('play');
  const replayBtn = document.getElementById('replay');
  const replayFloat = document.getElementById('replayFloat');
  const recStartBtn = document.getElementById('recStart');
  const recStopBtn  = document.getElementById('recStop');
  const shotBtn = document.getElementById('shot');
  const exportOneBtn = document.getElementById('exportOne');
  const hud = document.getElementById('hud');
  const recHUD = document.getElementById('recHUD');
  const recTime = document.getElementById('recTime');
  const dbg = document.getElementById('dbg');
  const supportNote = document.getElementById('supportNote');
  const nosrc = document.getElementById('nosrc');

  const ids = ["dt","thr","grey","preblur","gAlpha","decay","strength","expand"];
  const el  = Object.fromEntries(ids.map(id=>[id, document.getElementById(id)]));
  const out = Object.fromEntries(ids.map(id=>[id+"V", document.getElementById(id+"V")]));
  const stainOn = document.getElementById('stainOn');
  const sColor  = document.getElementById('sColor');
  const gBlend  = document.getElementById('gBlend');
  const formatSel = document.getElementById('format');
  const gUseColor = document.getElementById('gUseColor');
  const gColor    = document.getElementById('gColor');

  function sync(){
    out.dtV.textContent      = (+el.dt.value).toFixed(1);
    out.thrV.textContent     = el.thr.value;
    out.greyV.textContent    = el.grey.value;
    out.preblurV.textContent = el.preblur.value;
    out.gAlphaV.textContent  = (+el.gAlpha.value).toFixed(2);
    out.decayV.textContent   = (+el.decay.value).toFixed(3);
    out.strengthV.textContent= (+el.strength.value).toFixed(2);
    out.expandV.textContent  = el.expand.value;
  }
  [...ids.map(id=>el[id]), stainOn, sColor, gBlend, formatSel, gUseColor, gColor].forEach(x=>x.addEventListener('input', sync));
  sync();

  // ---------- Source ----------
  const vid = document.createElement('video');
  vid.crossOrigin = "anonymous";
  vid.playsInline = true;
  vid.muted = true;
  vid.loop = true;
  vid.preload = "auto";

  const qs = new URLSearchParams(location.search);
  const src = qs.get('src');
  if(src){ vid.src = src; }

  let mediaStream = null;
  file.addEventListener('change', e=>{
    const f = e.target.files[0]; if(!f) return;
    stopWebcam();
    resetState();
    vid.src = URL.createObjectURL(f);
    vid.play();
  });
  playBtn.addEventListener('click', ()=> vid.paused ? vid.play() : vid.pause());
  webcamBtn.addEventListener('click', ()=> startWebcam().catch(e=>alert('Webcam failed: '+e.message)));
  async function startWebcam(){
    stopWebcam();
    resetState();
    mediaStream = await navigator.mediaDevices.getUserMedia({video:true, audio:false});
    vid.srcObject = mediaStream;
    await vid.play();
  }
  function stopWebcam(){
    if(mediaStream){
      mediaStream.getTracks().forEach(t=>t.stop());
      mediaStream=null;
    }
  }

  // ---------- HiDPI sizing for PREVIEW ----------
  const proc = document.createElement('canvas');
  const pctx = proc.getContext('2d', {willReadFrequently:true});
  const maskCanvas = document.createElement('canvas');
  const maskCtx = maskCanvas.getContext('2d');
  const colCanvas = document.createElement('canvas');
  const colCtx = colCanvas.getContext('2d');

  function fit(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const r = can.final.getBoundingClientRect();
    const W = Math.max(2, Math.round(r.width*dpr));
    const H = Math.max(2, Math.round(r.height*dpr));
    for(const k in can){
      can[k].width=W; can[k].height=H;
    }
    proc.width=W; proc.height=H;
    maskCanvas.width=W; maskCanvas.height=H;
    colCanvas.width=W; colCanvas.height=H;
  }
  new ResizeObserver(fit).observe(can.final);
  fit(); // initial size

  // ---------- Buffers (preview res) ----------
  const buf = [];
  const MAX_SEC = 14;
  function pushFrame(img, t){
    buf.push({t, data: new Uint8ClampedArray(img.data), w: img.width, h: img.height});
    const cutoff = t - (MAX_SEC + 2);
    while(buf.length && buf[0].t < cutoff) buf.shift();
  }
  function getPastFrame(delta){
    const target = vid.currentTime - delta;
    for(let i=buf.length-1;i>=0;i--){
      if(buf[i].t <= target) return buf[i];
    }
    return buf[0] || null;
  }

  function drawVideoContained(ctx, video, W, H, blurPx){
    ctx.save();
    ctx.clearRect(0,0,W,H);
    if(blurPx>0) ctx.filter = `blur(${blurPx}px)`;
    const vw=video.videoWidth||0, vh=video.videoHeight||0;
    if(vw && vh){
      const s = Math.min(W/vw, H/vh);
      const dw = Math.round(vw*s), dh = Math.round(vh*s);
      const dx = Math.floor((W-dw)/2), dy = Math.floor((H-dh)/2);
      ctx.drawImage(video, dx,dy,dw,dh);
    }
    ctx.restore();
  }

  // ---------- Recording PREVIEW canvas ----------
  let recorder=null, chunks=[], recStartTime=0, recTimer=null, recMime="", recExt="webm";

  function bestSupported(){
    const mp4='video/mp4;codecs=avc1.42E01E,mp4a.40.2';
    const webm='video/webm;codecs=vp9,opus';
    const webm2='video/webm;codecs=vp8,opus';
    const canMp4 = !!(window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(mp4));
    const canWebm= !!(window.MediaRecorder && MediaRecorder.isTypeSupported && (MediaRecorder.isTypeSupported(webm)||MediaRecorder.isTypeSupported(webm2)));
    return {
      canMp4,
      canWebm,
      mp4,
      webm:(MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(webm)?webm:webm2)
    };
  }

  function refreshSupportNote(){
    const s=bestSupported();
    const fmt=document.getElementById('format').value;
    let msg='';
    if(fmt==='mp4'){
      msg = s.canMp4 ? '<span class="ok">MP4 recording supported ✓</span>' :
                       '<span class="warn">MP4 not supported here. Use Safari/WebKit or switch to WebM.</span>';
    }else if(fmt==='webm'){
      msg = s.canWebm ? 'WebM recording supported ✓' :
                        '<span class="warn">WebM not supported.</span>';
    }else{
      msg = s.canMp4
        ? 'Auto → MP4'
        : (s.canWebm ? 'Auto → WebM' : '<span class="warn">Recording unsupported.</span>');
    }
    supportNote.innerHTML = msg;
  }
  refreshSupportNote();
  document.getElementById('format').addEventListener('change', refreshSupportNote);

  function startRecording(){
    const s=bestSupported();
    const sel=document.getElementById('format').value;
    let mime='';
    if(sel==='mp4')   mime = s.canMp4 ? s.mp4 : '';
    else if(sel==='webm') mime = s.canWebm ? s.webm : '';
    else               mime = s.canMp4 ? s.mp4 : (s.canWebm ? s.webm : '');
    if(!mime){
      alert('Recording format not supported on this browser.');
      return;
    }

    const stream = can.final.captureStream
      ? can.final.captureStream(30)
      : can.final.mozCaptureStream(30);

    chunks=[];
    recorder = new MediaRecorder(stream, {
      mimeType:mime,
      videoBitsPerSecond: 8_000_000
    });
    recMime=mime;
    recExt = mime.startsWith('video/mp4') ? 'mp4' : 'webm';

    recorder.ondataavailable = e=>{
      if(e.data && e.data.size) chunks.push(e.data);
    };
    recorder.onstop = ()=>{
      const blob = new Blob(chunks, {type: recMime});
      const a = document.createElement('a');
      a.download = `wind_on_wall_${Date.now()}.${recExt}`;
      a.href = URL.createObjectURL(blob);
      a.click();
      stopRecUI();
    };

    recorder.start(250);

    recStartTime = performance.now();
    recTimer = setInterval(()=>{
      const t = Math.floor((performance.now()-recStartTime)/1000);
      const mm = String(Math.floor(t/60)).padStart(2,'0');
      const ss = String(t%60).padStart(2,'0');
      recTime.textContent = `REC ${mm}:${ss}`;
    },250);

    recHUD.style.display='flex';
    recStartBtn.disabled=true;
    recStopBtn.disabled=false;
  }

  function stopRecording(){
    if(recorder && recorder.state==='recording'){
      recorder.stop();
    }
  }
  function stopRecUI(){
    clearInterval(recTimer);
    recTimer=null;
    recHUD.style.display='none';
    recStartBtn.disabled=false;
    recStopBtn.disabled=true;
  }

  recStartBtn.addEventListener('click', startRecording);
  recStopBtn.addEventListener('click',  stopRecording);

  shotBtn.addEventListener('click', ()=>{
    const a = document.createElement('a');
    a.download = 'still_'+Date.now()+'.png';
    a.href = can.final.toDataURL('image/png');
    a.click();
  });

  // ---------- Replay ----------
  function resetState(){
    buf.length = 0;
    sctx.clearRect(0,0,can.stain.width,can.stain.height);
    gctx.clearRect(0,0,can.ghost.width,can.ghost.height);
  }
  function replay(){
    if(vid.srcObject){
      alert('Replay is for file/URL clips. Stop Webcam and load a clip to use Replay.');
      return;
    }
    if(!vid.currentSrc && !vid.src){
      alert('No clip loaded.');
      return;
    }
    if(recorder && recorder.state==='recording'){
      stopRecording();
    }
    try{
      vid.pause();
      resetState();
      const onSeeked = () => {
        vid.removeEventListener('seeked', onSeeked);
        vid.play();
      };
      vid.addEventListener('seeked', onSeeked, { once:true });
      vid.currentTime = 0;
    }catch(e){
      const src = vid.currentSrc || vid.src;
      if(src){
        resetState();
        vid.src = src;
        vid.play();
      }
    }
  }
  replayBtn.addEventListener('click', replay);
  replayFloat.addEventListener('click', replay);

  document.addEventListener('keydown', (e)=>{
    const t = e.target;
    if(t && (t.tagName==='INPUT' || t.tagName==='SELECT' || t.tagName==='TEXTAREA' || t.isContentEditable)) return;
    if(e.code === 'KeyR'){
      e.preventDefault();
      replay();
    } else if(e.code === 'Space'){
      e.preventDefault();
      vid.paused ? vid.play() : vid.pause();
    }
  });

  // ---------- Helpers ----------
  function hexToRgb(hex){
    const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return m ? [parseInt(m[1],16), parseInt(m[2],16), parseInt(m[3],16)] : [255,255,255];
  }

  // ---------- Main PREVIEW loop ----------
  let lastT=0, fpsEMA=0;
  requestAnimationFrame(function tick(now){
    requestAnimationFrame(tick);

    const W = can.final.width, H = can.final.height;

    // base bg
    const grey = +el.grey.value;
    fctx.clearRect(0,0,W,H);
    fctx.fillStyle = `rgb(${grey},${grey},${grey})`;
    fctx.fillRect(0,0,W,H);

    if(vid.readyState < 2){
      nosrc.style.display = 'block';
      return;
    } else {
      nosrc.style.display = 'none';
    }

    // 1) current frame → analysis buffer (preview res)
    drawVideoContained(pctx, vid, W, H, +el.preblur.value);
    const curr = pctx.getImageData(0,0,W,H);
    pushFrame(curr, vid.currentTime);

    // 2) past frame
    const past = getPastFrame(+el.dt.value);
    if(!past){ return; }

    // 3) motion mask + ghosts
    const c = curr.data, p = past.data;
    const ghostImg = gctx.createImageData(W,H);
    const gd = ghostImg.data;
    const thr = +el.thr.value;
    const mask = new Uint8ClampedArray(W*H);
    let changedCount=0;

    for(let i=0,j=0;i<c.length;i+=4,j++){
      const r=c[i], g=c[i+1], b=c[i+2];
      const pr=p[i], pg=p[i+1], pb=p[i+2];
      const lc = r*0.2126 + g*0.7152 + b*0.0722;
      const lp = pr*0.2126 + pg*0.7152 + pb*0.0722;
      const d = Math.abs(lc - lp);

      if(d > thr){
        changedCount++;
        mask[j]=255;

        if (gUseColor.checked) {
          const [cr,cg,cb] = hexToRgb(gColor.value);
          const a = Math.max(40, Math.min(255, (d - thr) * 8));
          gd[i]=cr; gd[i+1]=cg; gd[i+2]=cb; gd[i+3]=a;
        } else {
          gd[i]   = (r + (255 - pr)) * 0.5;
          gd[i+1] = (g + (255 - pg)) * 0.5;
          gd[i+2] = (b + (255 - pb)) * 0.5;
          gd[i+3] = 255;
        }
      } else {
        gd[i]=gd[i+1]=gd[i+2]=0; gd[i+3]=0;
      }
    }
    gctx.putImageData(ghostImg,0,0);

    // 4) stain accumulation
    if(stainOn.checked){
      const decay = +el.decay.value;
      sctx.globalCompositeOperation='destination-out';
      sctx.fillStyle = `rgba(0,0,0,${1-decay})`;
      sctx.fillRect(0,0,W,H);
      sctx.globalCompositeOperation='source-over';

      const mImg = maskCtx.createImageData(W,H);
      const mdat = mImg.data;
      for(let j=0,k=0;j<mask.length;j++,k+=4){
        const v = mask[j];
        mdat[k]=mdat[k+1]=mdat[k+2]=v;
        mdat[k+3]=v;
      }
      maskCtx.putImageData(mImg,0,0);

      colCtx.clearRect(0,0,W,H);
      const expand = +el.expand.value;
      if(expand>0){
        colCtx.filter = `blur(${expand}px)`;
      }
      colCtx.drawImage(maskCanvas,0,0);
      colCtx.filter='none';
      colCtx.globalCompositeOperation='source-in';
      colCtx.fillStyle = sColor.value;
      colCtx.globalAlpha = +el.strength.value;
      colCtx.fillRect(0,0,W,H);
      colCtx.globalCompositeOperation='source-over';
      colCtx.globalAlpha = 1;
      sctx.drawImage(colCanvas,0,0);
    }

    // 5) compose -> final preview canvas
    if(stainOn.checked){
      fctx.globalCompositeOperation='multiply';
      fctx.drawImage(can.stain,0,0);
      fctx.globalCompositeOperation='source-over';
    }
    fctx.globalAlpha = +el.gAlpha.value;
    fctx.globalCompositeOperation = gBlend.value;
    fctx.drawImage(can.ghost,0,0);
    fctx.globalAlpha = 1;
    fctx.globalCompositeOperation='source-over';

    // HUD
    const dt = now - lastT; lastT = now;
    const inst = dt>0 ? 1000/dt : 0;
    fpsEMA = fpsEMA? fpsEMA*0.9 + inst*0.1 : inst;
    const pct = 100*(changedCount/(W*H));
    hud.textContent =
`Δt = ${(+el.dt.value).toFixed(1)} s
thr = ${el.thr.value}, pre-blur = ${el.preblur.value}, grey = ${el.grey.value}
ghost: ${gBlend.value}, α=${(+el.gAlpha.value).toFixed(2)}${gUseColor.checked?`, color=${gColor.value}`:''}
stain: decay=${(+el.decay.value).toFixed(3)}, expand=${el.expand.value}, strength=${(+el.strength.value).toFixed(2)}
changed = ${pct.toFixed(1)}%`;

    const sSup = bestSupported();
    dbg.textContent = `buffer: ${buf.length} | fps ~ ${fpsEMA.toFixed(1)} | support: ${sSup.canMp4?'MP4✓':'MP4×'}/${sSup.canWebm?'WebM✓':'WebM×'}`;
  });

  vid.addEventListener('loadeddata', ()=>{ vid.play().catch(()=>{}); });

  // ---------- 1:1 / native export ----------
  exportOneBtn.addEventListener('click', exportSourceOnce);

  async function exportSourceOnce(){
    // only file/URL clips (no webcam)
    if (vid.srcObject){
      alert('1:1 export is for file/URL clips, not webcam.');
      return;
    }
    if(!(vid.currentSrc || vid.src)){
      alert('Load a clip first.');
      return;
    }

    // ensure metadata
    if(vid.readyState<1){
      await new Promise(res=>vid.addEventListener('loadedmetadata',res,{once:true}));
    }
    const vw=vid.videoWidth|0, vh=vid.videoHeight|0;
    if(!vw||!vh){
      alert('Video metadata unavailable.');
      return;
    }

    // choose mime
    const sup = bestSupported();
    let mime='',ext='webm';
    if(sup.canMp4){ mime=sup.mp4; ext='mp4'; }
    else if(sup.canWebm){ mime=sup.webm; ext='webm'; }
    else {
      alert('Export not supported on this browser. Try Safari (MP4) or Chrome/Firefox (WebM).');
      return;
    }

    exportOneBtn.disabled=true;
    recStartBtn.disabled=true;

    // snapshot current playback state
    const prevState = {
      loop: vid.loop,
      rate: vid.playbackRate,
      paused: vid.paused,
      t: vid.currentTime
    };
    vid.pause();
    vid.loop=false;
    vid.playbackRate=1;

    // build hidden hi-res pipeline
    const hi = {
      final: document.createElement('canvas'),
      ghost: document.createElement('canvas'),
      stain: document.createElement('canvas'),
      work:  document.createElement('canvas'),
      mask:  document.createElement('canvas'),
      col:   document.createElement('canvas')
    };
    for(const k in hi){
      hi[k].width = vw;
      hi[k].height= vh;
    }
    const hfctx = hi.final.getContext('2d');
    const hgctx = hi.ghost.getContext('2d');
    const hsctx = hi.stain.getContext('2d');
    const hpctx = hi.work.getContext('2d', {willReadFrequently:true});
    const hMaskCtx = hi.mask.getContext('2d');
    const hColCtx  = hi.col.getContext('2d');

    // hi-res buffer (independent of preview `buf`)
    const hiBuf=[];
    const HI_MAX_SEC=14;
    function hiPushFrame(imgData, t){
      hiBuf.push({
        t,
        data:new Uint8ClampedArray(imgData.data),
        w:imgData.width,
        h:imgData.height
      });
      const cutoff = t - (HI_MAX_SEC+2);
      while(hiBuf.length && hiBuf[0].t<cutoff) hiBuf.shift();
    }
    function hiGetPastFrame(delta, nowT){
      const target = nowT - delta;
      for(let i=hiBuf.length-1;i>=0;i--){
        if(hiBuf[i].t <= target) return hiBuf[i];
      }
      return hiBuf[0] || null;
    }
    function hexToRgbLocal(hex){
      const m=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return m ? [parseInt(m[1],16), parseInt(m[2],16), parseInt(m[3],16)] : [255,255,255];
    }

    // render ONE hi-res frame from current vid state
    function renderHiFrame(){
      const W=vw, H=vh;

      // base grey
      const grey=+el.grey.value;
      hfctx.clearRect(0,0,W,H);
      hfctx.fillStyle=`rgb(${grey},${grey},${grey})`;
      hfctx.fillRect(0,0,W,H);

      if(vid.readyState<2){
        return;
      }

      // draw raw video full-bleed at native res
      hpctx.clearRect(0,0,W,H);
      hpctx.drawImage(vid,0,0,W,H);

      const curr=hpctx.getImageData(0,0,W,H);
      const nowT=vid.currentTime;
      hiPushFrame(curr, nowT);

      const past=hiGetPastFrame(+el.dt.value, nowT);
      if(!past){
        // no history yet
        if(stainOn.checked){
          hfctx.globalCompositeOperation='multiply';
          hfctx.drawImage(hi.stain,0,0);
          hfctx.globalCompositeOperation='source-over';
        }
        return;
      }

      // motion diff at hi-res
      const c=curr.data, p=past.data;
      const ghostImg=hgctx.createImageData(W,H);
      const gd=ghostImg.data;
      const thr=+el.thr.value;
      const mask=new Uint8ClampedArray(W*H);

      for(let i=0,j=0;i<c.length;i+=4,j++){
        const r=c[i], g=c[i+1], b=c[i+2];
        const pr=p[i],pg=p[i+1],pb=p[i+2];
        const lc=r*0.2126+g*0.7152+b*0.0722;
        const lp=pr*0.2126+pg*0.7152+pb*0.0722;
        const d=Math.abs(lc-lp);

        if(d>thr){
          mask[j]=255;
          if(gUseColor.checked){
            const [cr,cg,cb]=hexToRgbLocal(gColor.value);
            const a=Math.max(40,Math.min(255,(d-thr)*8));
            gd[i]=cr; gd[i+1]=cg; gd[i+2]=cb; gd[i+3]=a;
          }else{
            gd[i]=(r+(255-pr))*0.5;
            gd[i+1]=(g+(255-pg))*0.5;
            gd[i+2]=(b+(255-pb))*0.5;
            gd[i+3]=255;
          }
        }else{
          gd[i]=gd[i+1]=gd[i+2]=0; gd[i+3]=0;
        }
      }
      hgctx.putImageData(ghostImg,0,0);

      // stain accumulation hi-res
      if(stainOn.checked){
        const decay=+el.decay.value;
        hsctx.globalCompositeOperation='destination-out';
        hsctx.fillStyle=`rgba(0,0,0,${1-decay})`;
        hsctx.fillRect(0,0,W,H);
        hsctx.globalCompositeOperation='source-over';

        const mImg=hMaskCtx.createImageData(W,H);
        const mdat=mImg.data;
        for(let j=0,k=0;j<mask.length;j++,k+=4){
          const v=mask[j];
          mdat[k]=mdat[k+1]=mdat[k+2]=v;
          mdat[k+3]=v;
        }
        hMaskCtx.putImageData(mImg,0,0);

        hColCtx.clearRect(0,0,W,H);
        const expand=+el.expand.value;
        if(expand>0){
          hColCtx.filter=`blur(${expand}px)`;
        }
        hColCtx.drawImage(hi.mask,0,0);
        hColCtx.filter='none';
        hColCtx.globalCompositeOperation='source-in';
        hColCtx.fillStyle=sColor.value;
        hColCtx.globalAlpha=+el.strength.value;
        hColCtx.fillRect(0,0,W,H);
        hColCtx.globalCompositeOperation='source-over';
        hColCtx.globalAlpha=1;

        hsctx.drawImage(hi.col,0,0);
      }

      // compose hi-res final frame
      if(stainOn.checked){
        hfctx.globalCompositeOperation='multiply';
        hfctx.drawImage(hi.stain,0,0);
        hfctx.globalCompositeOperation='source-over';
      }
      hfctx.globalAlpha=+el.gAlpha.value;
      hfctx.globalCompositeOperation=gBlend.value;
      hfctx.drawImage(hi.ghost,0,0);
      hfctx.globalAlpha=1;
      hfctx.globalCompositeOperation='source-over';
    }

    // setup MediaRecorder on hi.final (native res)
    const expChunks=[];
    const hiStream = hi.final.captureStream
      ? hi.final.captureStream(30)
      : hi.final.mozCaptureStream(30);
    const expRecorder=new MediaRecorder(hiStream,{
      mimeType:mime,
      videoBitsPerSecond:8_000_000
    });
    expRecorder.ondataavailable=e=>{
      if(e.data && e.data.size) expChunks.push(e.data);
    };
    const recDone=new Promise(resolve=>{
      expRecorder.onstop=resolve;
    });

    // run a parallel loop that mirrors preview logic but at hi-res
    let running=true;
    function hiLoop(){
      if(!running) return;
      renderHiFrame();
      requestAnimationFrame(hiLoop);
    }

    // reset clip to 0 and play through once
    async function resetClipToZeroAndPlay(){
      return new Promise(ok=>{
        function afterSeek(){
          vid.removeEventListener('seeked', afterSeek);
          vid.play().catch(()=>{});
          ok();
        }
        const onData=()=>{
          vid.removeEventListener('loadeddata', onData);
          vid.addEventListener('seeked', afterSeek, {once:true});
          try{ vid.currentTime=0; }
          catch(_){ afterSeek(); }
        };
        if(vid.readyState>=2){
          onData();
        }else{
          vid.addEventListener('loadeddata', onData, {once:true});
        }
      });
    }

    await resetClipToZeroAndPlay();
    expRecorder.start(250);
    hiLoop();

    // safety timeout in case 'ended' never fires
    const safetyMs=(isFinite(vid.duration)?vid.duration:60)*1000+5000;
    const safetyTimer=setTimeout(()=>finalize(), safetyMs);

    vid.addEventListener('ended', finalize, {once:true});

    function finalize(){
      clearTimeout(safetyTimer);
      running=false;
      try{expRecorder.stop();}catch(_){}
    }

    // wait for recording to finish
    await recDone;

    // save result
    const blob=new Blob(expChunks,{type:mime});
    const a=document.createElement('a');
    a.download=`wind_on_wall_1x_${vw}x${vh}_${Date.now()}.${ext}`;
    a.href=URL.createObjectURL(blob);
    a.click();

    // restore prev playback state
    vid.loop=prevState.loop;
    vid.playbackRate=prevState.rate;
    try{ vid.currentTime=prevState.t; }catch(_){}
    if(!prevState.paused){
      try{ await vid.play(); }catch(_){}
    }

    exportOneBtn.disabled=false;
    recStartBtn.disabled=false;
  }

})(); // IIFE
</script>
</body>
</html>
