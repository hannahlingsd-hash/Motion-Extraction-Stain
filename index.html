<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Wind-on-Wall — Ghosts + Stain (hi-res)</title>

<style>
  :root{
    --bg:#fff; --fg:#000; --mut:#333; --line:#000;
    --colR:320px;
    --track-fill:#111;
    --track-bg:#cfcfcf;
  }
  html,body{
    height:100%;
    margin:0;
    background:var(--bg);
    color:var(--fg);
    font:13px/1.45 Arial, Helvetica, sans-serif;
  }
  body{overflow:hidden;}
  *{box-sizing:border-box;border-radius:0}
  button,input,select,label{font:inherit;color:var(--fg);background:#fff;margin:0}

  .wrap{
    display:grid;
    grid-template-columns: minmax(0,1fr) var(--colR);
    gap:16px;
    height:100vh;
    padding:12px;
    overflow:hidden;
  }

  main{
    position:relative;
    background:#000;
    border:1px solid var(--line);
    border-radius:6px;
    overflow:hidden;
    min-width:0;
  }

  /* stacked canvases fill main, scale with contain */
  .layer{
    position:absolute;
    inset:0;
    width:100%;
    height:100%;
    object-fit:contain;
    background:transparent;
  }

  aside{
    display:flex;
    flex-direction:column;
    min-width:0;
    border-left:1px solid var(--line);
    padding-left:8px;
    overflow:auto;
  }

  h1{font-size:13px;font-weight:bold;margin:0 0 8px;line-height:1.3;}

  fieldset{
    border:1px solid var(--line);
    border-radius:6px;
    margin:0 0 12px;
    padding:8px;
  }
  legend{
    padding:0 4px;
    font-size:12px;
    line-height:1.2;
    color:var(--mut);
  }

  .row{
    display:flex;
    flex-wrap:wrap;
    align-items:center;
    gap:6px;
    margin:6px 0;
  }

  .row label{
    flex:1 1 auto;
    font-size:12px;
    color:var(--mut);
  }

  .row input[type="range"],
  .row select{
    flex:2 1 auto;
    min-width:0;
  }

  .row .val{
    font-size:12px;
    min-width:2ch;
    text-align:right;
  }

  .small{
    font-size:11px;
    color:var(--mut);
    line-height:1.4;
    word-break:break-word;
  }

  .btn{
    appearance:none;
    border:1px solid var(--line);
    background:#fff;
    color:#000;
    border-radius:4px;
    padding:4px 8px;
    cursor:pointer;
    font-size:12px;
    line-height:1.3;
  }
  .btn:disabled{
    opacity:.4;
    cursor:not-allowed;
  }

  .kbd{
    font:11px/1.2 ui-monospace,monospace;
    background:#eee;
    border:1px solid #999;
    border-radius:4px;
    padding:1px 4px;
    color:#000;
  }

  .hudBox{
    position:absolute;
    top:8px;
    left:8px;
    background:rgba(0,0,0,.5);
    color:#fff;
    border-radius:4px;
    padding:4px 6px;
    font:11px/1.3 ui-monospace,monospace;
    white-space:pre;
    pointer-events:none;
    max-width:60%;
  }

  .recHUD{
    position:absolute;
    top:8px;
    right:8px;
    background:rgba(0,0,0,.6);
    color:#fff;
    border-radius:999px;
    padding:4px 8px;
    font:11px/1.3 ui-monospace,monospace;
    display:flex;
    align-items:center;
    gap:6px;
    pointer-events:none;
  }
  .recDot{
    width:7px;
    height:7px;
    background:#f33;
    border-radius:50%;
    box-shadow:0 0 6px #f33;
  }
  .recHUD[hidden]{display:none;}

  .nosrc{
    position:absolute;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    font:12px ui-monospace,monospace;
    color:#ccc;
    background:#000;
    pointer-events:none;
  }
  .nosrc[hidden]{display:none;}

  .fabReplay{
    position:absolute;
    top:40px;
    right:8px;
    z-index:5;
    border:1px solid var(--line);
    background:#fff;
    color:#000;
    border-radius:999px;
    padding:4px 8px;
    font-size:12px;
    line-height:1.3;
    cursor:pointer;
  }

  /* little group headings */
  .secHead{
    font-size:11px;
    font-weight:bold;
    margin:12px 0 4px;
    color:#000;
  }

  /* checkbox row helper */
  .row.chk label{
    flex:0 0 auto;
    min-width:auto;
  }
</style>
</head>
<body>

<div class="wrap">
  <main>
    <!-- render stack -->
    <canvas id="stain" class="layer"></canvas>
    <canvas id="ghost" class="layer"></canvas>
    <canvas id="haunt" class="layer"></canvas>
    <canvas id="recall" class="layer"></canvas>
    <canvas id="edge" class="layer"></canvas>
    <canvas id="final" class="layer"></canvas>

    <div id="hud" class="hudBox"></div>
    <div id="recHUD" class="recHUD" hidden>
      <div class="recDot"></div>
      <div id="recTime">REC 00:00</div>
    </div>
    <div id="nosrc" class="nosrc" hidden>load a clip or use the webcam</div>
    <button id="replayFloat" class="fabReplay" title="Replay (R)">↺</button>
  </main>

  <aside>
    <h1>Wind-on-Wall — Ghosts + Stain (hi-res)</h1>

    <div class="row">
      <input id="file" type="file" accept="video/*" class="btn" style="flex:1 1 auto;min-width:0;">
      <button id="webcam" class="btn" style="flex:0 0 auto;">Webcam</button>
      <button id="play" class="btn" style="flex:0 0 auto;">Play/Pause</button>
    </div>

    <div class="row">
      <button id="replay" class="btn" style="flex:0 0 auto;">↺ Replay</button>
      <span class="small" style="flex:1 1 auto;">Shortcut: <span class="kbd">R</span></span>
    </div>

    <div class="row small">
      Or URL:
      <span class="kbd">?src=clip.mp4</span>
      (same-origin or CORS)
    </div>

    <fieldset>
      <legend>Temporal window</legend>
      <div class="row">
        <label>Δt (seconds)</label>
        <input id="dt" type="range" min="2" max="10" step="0.5" value="6">
        <span id="dtV" class="val">6.0</span>
      </div>

      <div class="row">
        <label>Diff threshold</label>
        <input id="thr" type="range" min="4" max="60" value="18">
        <span id="thrV" class="val">18</span>
      </div>

      <div class="row">
        <label>Grey level</label>
        <input id="grey" type="range" min="60" max="200" value="120">
        <span id="greyV" class="val">120</span>
      </div>

      <div class="row">
        <label>Pre-blur (px)</label>
        <input id="preblur" type="range" min="0" max="3" value="0">
        <span id="preblurV" class="val">0</span>
      </div>
    </fieldset>

    <fieldset>
      <legend>Ghosts (motion)</legend>
      <div class="row">
        <label>Ghost opacity</label>
        <input id="gAlpha" type="range" min="0" max="1" step="0.05" value="0.7">
        <span id="gAlphaV" class="val">0.70</span>
      </div>

      <div class="row">
        <label>Blend mode</label>
        <select id="gBlend">
          <option value="normal">Normal</option>
          <option value="screen" selected>Screen</option>
          <option value="lighter">Lighter</option>
        </select>
      </div>

      <div class="row chk">
        <label>Use custom color</label>
        <input id="gUseColor" type="checkbox">
        <input id="gColor" type="color" value="#ffffff">
      </div>
    </fieldset>

    <fieldset>
      <legend>Stain (residual blotches)</legend>
      <div class="row chk">
        <label>Enable stain</label>
        <input id="stainOn" type="checkbox" checked>
      </div>

      <div class="row">
        <label>Decay</label>
        <input id="decay" type="range" min="0.90" max="0.995" step="0.001" value="0.970">
        <span id="decayV" class="val">0.970</span>
      </div>

      <div class="row">
        <label>Strength</label>
        <input id="strength" type="range" min="0.1" max="1" step="0.05" value="0.50">
        <span id="strengthV" class="val">0.50</span>
      </div>

      <div class="row">
        <label>Expand (px)</label>
        <input id="expand" type="range" min="0" max="8" step="1" value="2">
        <span id="expandV" class="val">2</span>
      </div>

      <div class="row">
        <label>Stain color</label>
        <input id="sColor" type="color" value="#223b7a">
      </div>
    </fieldset>

    <fieldset>
      <legend>Recall / Haunt</legend>
      <div class="row chk">
        <label>Recall on</label>
        <input id="recallOn" type="checkbox">
      </div>
      <div class="row">
        <label>Recall prob</label>
        <input id="recallProb" type="range" min="0" max="1" step="0.01" value="0.10">
        <span id="recallProbV" class="val">0.10</span>
      </div>
      <div class="row">
        <label>Recall linger</label>
        <input id="recallLinger" type="range" min="0.2" max="3" step="0.1" value="1.2">
        <span id="recallLingerV" class="val">1.2</span>
      </div>
      <div class="row">
        <label>Recall color</label>
        <input id="recallColor" type="color" value="#00e7ff">
      </div>
    </fieldset>

    <fieldset>
      <legend>Edges / Outlines</legend>
      <div class="row">
        <label>Edge thr</label>
        <input id="edgeThr" type="range" min="10" max="200" step="1" value="40">
        <span id="edgeThrV" class="val">40</span>
      </div>

      <div class="row chk">
        <label>Ghost edge</label>
        <input id="ghostEdgeOn" type="checkbox" checked>
        <input id="ghostEdgeColor" type="color" value="#ffffff">
        <label style="flex:0 0 auto;">α</label>
        <input id="ghostEdgeAlpha" type="range" min="0" max="1" step="0.05" value="0.8" style="flex:1 1 60px;">
      </div>

      <div class="row chk">
        <label>Stain edge</label>
        <input id="stainEdgeOn" type="checkbox">
        <input id="stainEdgeColor" type="color" value="#223b7a">
        <label style="flex:0 0 auto;">α</label>
        <input id="stainEdgeAlpha" type="range" min="0" max="1" step="0.05" value="0.7" style="flex:1 1 60px;">
      </div>

      <div class="row chk">
        <label>Recall edge</label>
        <input id="recallEdgeOn" type="checkbox">
        <input id="recallEdgeColor" type="color" value="#00e7ff">
        <label style="flex:0 0 auto;">α</label>
        <input id="recallEdgeAlpha" type="range" min="0" max="1" step="0.05" value="0.7" style="flex:1 1 60px;">
      </div>

      <div class="row chk">
        <label>Linger edge</label>
        <input id="lingerEdgeOn" type="checkbox">
        <input id="lingerEdgeColor" type="color" value="#ff00ff">
        <label style="flex:0 0 auto;">α</label>
        <input id="lingerEdgeAlpha" type="range" min="0" max="1" step="0.05" value="0.8" style="flex:1 1 60px;">
      </div>
    </fieldset>

    <fieldset>
      <legend>Export</legend>

      <div class="row">
        <label>Format</label>
        <select id="format">
          <option value="mp4">MP4 (preferred)</option>
          <option value="webm">WebM</option>
          <option value="auto" selected>Auto (best available)</option>
        </select>
      </div>

      <div class="row">
        <button id="recStart" class="btn" style="flex:1 1 auto;">Start Rec (Preview)</button>
        <button id="recStop" class="btn" style="flex:1 1 auto;" disabled>Stop &amp; Save</button>
      </div>

      <div class="row">
        <button id="shot" class="btn" style="flex:1 1 auto;">Export PNG</button>
      </div>

      <div class="row">
        <button id="exportOne" class="btn" style="flex:1 1 auto;">Export 1:1 Native</button>
      </div>

      <div class="row small" id="supportNote"></div>
      <div class="row small" id="dbg">buffer: 0 | fps —</div>
    </fieldset>
  </aside>
</div>

<script>
(function(){
  // ---------- Elements / Canvases ----------
  const can = {
    stain:  document.getElementById('stain'),
    ghost:  document.getElementById('ghost'),
    haunt:  document.getElementById('haunt'),
    recall: document.getElementById('recall'),
    edge:   document.getElementById('edge'),
    final:  document.getElementById('final'),
  };

  const sctx        = can.stain.getContext('2d');
  const gctx        = can.ghost.getContext('2d');
  const hauntCtx    = can.haunt.getContext('2d');
  const recallCtx   = can.recall.getContext('2d');
  const edgeCtx     = can.edge.getContext('2d');
  const fctx        = can.final.getContext('2d');

  // offscreen helpers
  const proc         = document.createElement('canvas');
  const pctx         = proc.getContext('2d',{willReadFrequently:true});
  const maskCanvas   = document.createElement('canvas');
  const maskCtx      = maskCanvas.getContext('2d');
  const colCanvas    = document.createElement('canvas');
  const colCtx       = colCanvas.getContext('2d');
  const tintCanvas   = document.createElement('canvas');
  const tintCtx      = tintCanvas.getContext('2d');
  const edgeCanvas   = document.createElement('canvas');
  const edgeCtxOff   = edgeCanvas.getContext('2d');
  const edgeLayerCanvas = document.createElement('canvas');
  const edgeLayerCtx    = edgeLayerCanvas.getContext('2d');

  // ---------- DOM controls ----------
  const file          = document.getElementById('file');
  const webcamBtn     = document.getElementById('webcam');
  const playBtn       = document.getElementById('play');
  const replayBtn     = document.getElementById('replay');
  const replayFloat   = document.getElementById('replayFloat');
  const recStartBtn   = document.getElementById('recStart');
  const recStopBtn    = document.getElementById('recStop');
  const shotBtn       = document.getElementById('shot');
  const exportOneBtn  = document.getElementById('exportOne');

  const hud           = document.getElementById('hud');
  const recHUD        = document.getElementById('recHUD');
  const recTime       = document.getElementById('recTime');
  const dbg           = document.getElementById('dbg');
  const supportNote   = document.getElementById('supportNote');
  const nosrc         = document.getElementById('nosrc');

  const ids = [
    "dt","thr","grey","preblur","gAlpha",
    "decay","strength","expand",
    "recallProb","recallLinger","edgeThr",
    "ghostEdgeAlpha","stainEdgeAlpha","recallEdgeAlpha","lingerEdgeAlpha"
  ];
  const el = Object.fromEntries(ids.map(id=>[id, document.getElementById(id)]));
  const out = Object.fromEntries([
    ["dt","dtV"],["thr","thrV"],["grey","greyV"],["preblur","preblurV"],
    ["gAlpha","gAlphaV"],["decay","decayV"],["strength","strengthV"],
    ["expand","expandV"],
    ["recallProb","recallProbV"],["recallLinger","recallLingerV"],
    ["edgeThr","edgeThrV"],
  ].map(([a,b])=>[b, document.getElementById(b)]));

  const stainOn          = document.getElementById('stainOn');
  const sColor           = document.getElementById('sColor');
  const gBlend           = document.getElementById('gBlend');
  const formatSel        = document.getElementById('format');
  const gUseColor        = document.getElementById('gUseColor');
  const gColor           = document.getElementById('gColor');

  const recallOn         = document.getElementById('recallOn');
  const recallProb       = document.getElementById('recallProb');
  const recallColor      = document.getElementById('recallColor');
  const recallLinger     = document.getElementById('recallLinger');

  const ghostEdgeOn      = document.getElementById('ghostEdgeOn');
  const ghostEdgeColor   = document.getElementById('ghostEdgeColor');
  const ghostEdgeAlpha   = document.getElementById('ghostEdgeAlpha');
  const stainEdgeOn      = document.getElementById('stainEdgeOn');
  const stainEdgeColor   = document.getElementById('stainEdgeColor');
  const stainEdgeAlpha   = document.getElementById('stainEdgeAlpha');
  const recallEdgeOn     = document.getElementById('recallEdgeOn');
  const recallEdgeColor  = document.getElementById('recallEdgeColor');
  const recallEdgeAlpha  = document.getElementById('recallEdgeAlpha');
  const lingerEdgeOn     = document.getElementById('lingerEdgeOn');
  const lingerEdgeColor  = document.getElementById('lingerEdgeColor');
  const lingerEdgeAlpha  = document.getElementById('lingerEdgeAlpha');
  const edgeThr          = document.getElementById('edgeThr');

  function syncVals(){
    if(out.dtV)              out.dtV.textContent = (+el.dt.value).toFixed(1);
    if(out.thrV)             out.thrV.textContent = el.thr.value;
    if(out.greyV)            out.greyV.textContent = el.grey.value;
    if(out.preblurV)         out.preblurV.textContent = el.preblur.value;
    if(out.gAlphaV)          out.gAlphaV.textContent = (+el.gAlpha.value).toFixed(2);
    if(out.decayV)           out.decayV.textContent = (+el.decay.value).toFixed(3);
    if(out.strengthV)        out.strengthV.textContent = (+el.strength.value).toFixed(2);
    if(out.expandV)          out.expandV.textContent = el.expand.value;

    if(out.recallProbV)      out.recallProbV.textContent = (+recallProb.value).toFixed(2);
    if(out.recallLingerV)    out.recallLingerV.textContent = (+recallLinger.value).toFixed(1);
    if(out.edgeThrV)         out.edgeThrV.textContent = edgeThr.value;
  }

  [
    ...ids.map(id=>el[id]),
    stainOn,sColor,gBlend,formatSel,gUseColor,gColor,
    recallOn,recallProb,recallColor,recallLinger,
    ghostEdgeOn,ghostEdgeColor,ghostEdgeAlpha,
    stainEdgeOn,stainEdgeColor,stainEdgeAlpha,
    recallEdgeOn,recallEdgeColor,recallEdgeAlpha,
    lingerEdgeOn,lingerEdgeColor,lingerEdgeAlpha,
    edgeThr
  ].forEach(x=>{ if(x) x.addEventListener('input', syncVals); });
  syncVals();

  // ---------- Video source handling ----------
  const vid = document.createElement('video');
  vid.crossOrigin = "anonymous";
  vid.playsInline = true;
  vid.muted = true;
  vid.loop = true;
  vid.preload = "auto";

  const qs = new URLSearchParams(location.search);
  const qsSrc = qs.get('src');
  if(qsSrc){ vid.src = qsSrc; }

  let mediaStream = null;

  file.addEventListener('change', e=>{
    const f = e.target.files[0];
    if(!f) return;
    stopWebcam();
    resetState();
    vid.src = URL.createObjectURL(f);
    vid.play().catch(()=>{});
  });

  playBtn.addEventListener('click', ()=>{
    if(vid.paused) vid.play().catch(()=>{}); else vid.pause();
  });

  webcamBtn.addEventListener('click', ()=>{
    startWebcam().catch(e=>alert('Webcam failed: '+e.message));
  });

  async function startWebcam(){
    stopWebcam();
    resetState();
    mediaStream = await navigator.mediaDevices.getUserMedia({video:true, audio:false});
    vid.srcObject = mediaStream;
    await vid.play();
  }
  function stopWebcam(){
    if(mediaStream){
      mediaStream.getTracks().forEach(t=>t.stop());
      mediaStream=null;
    }
  }

  // ---------- HiDPI responsive sizing for preview ----------
  function fitPreview(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);

    // measure <main> box
    const r = can.final.getBoundingClientRect();
    const W = Math.max(2, Math.round(r.width*dpr));
    const H = Math.max(2, Math.round(r.height*dpr));

    // set working preview res
    can.final.width=W;   can.final.height=H;
    can.stain.width=W;   can.stain.height=H;
    can.ghost.width=W;   can.ghost.height=H;
    can.haunt.width=W;   can.haunt.height=H;
    can.recall.width=W;  can.recall.height=H;
    can.edge.width=W;    can.edge.height=H;

    proc.width=W;        proc.height=H;
    maskCanvas.width=W;  maskCanvas.height=H;
    colCanvas.width=W;   colCanvas.height=H;
    tintCanvas.width=W;  tintCanvas.height=H;
    edgeCanvas.width=W;  edgeCanvas.height=H;
    edgeLayerCanvas.width=W; edgeLayerCanvas.height=H;
  }
  new ResizeObserver(fitPreview).observe(can.final);
  fitPreview();

  // ---------- Motion buffer ----------
  const buf = [];
  const MAX_SEC = 14;
  function pushFrame(img, t){
    buf.push({
      t,
      data: new Uint8ClampedArray(img.data),
      w: img.width,
      h: img.height
    });
    const cutoff = t - (MAX_SEC + 2);
    while(buf.length && buf[0].t < cutoff) buf.shift();
  }
  function getPastFrame(delta){
    const target = vid.currentTime - delta;
    for(let i=buf.length-1;i>=0;i--){
      if(buf[i].t <= target) return buf[i];
    }
    return buf[0] || null;
  }

  // ---------- Helper utilities ----------
  function hexToRgb(hex){
    const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return m ? [parseInt(m[1],16), parseInt(m[2],16), parseInt(m[3],16)] : [255,255,255];
  }

  function drawVideoContained(ctx, video, W, H, blurPx){
    ctx.save();
    ctx.clearRect(0,0,W,H);
    if(blurPx>0) ctx.filter = `blur(${blurPx}px)`;
    const vw = video.videoWidth || 0;
    const vh = video.videoHeight || 0;
    if(vw && vh){
      const s = Math.min(W/vw, H/vh);
      const dw = Math.round(vw*s);
      const dh = Math.round(vh*s);
      const dx = Math.floor((W-dw)/2);
      const dy = Math.floor((H-dh)/2);
      ctx.drawImage(video, dx,dy,dw,dh);
    }
    ctx.restore();
  }

  function rgbaFrom(hex, a01){
    const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex||'#000000');
    return [
      parseInt(m[1],16),
      parseInt(m[2],16),
      parseInt(m[3],16),
      Math.max(0,Math.min(1,a01||1))
    ];
  }

  function drawOutlineFrom(srcCanvas, colorHex, alpha01){
    const W = srcCanvas.width, H = srcCanvas.height;
    if(!W||!H) return;
    const sctxL = srcCanvas.getContext('2d');
    const img  = sctxL.getImageData(0,0,W,H);
    const d    = img.data;
    const L    = new Uint8ClampedArray(W*H);

    for (let i=0,j=0;i<d.length;i+=4,++j){
      const lum = d[i]*0.2126 + d[i+1]*0.7152 + d[i+2]*0.0722;
      const a   = d[i+3];
      L[j] = Math.max(lum, a);
    }

    const E = new Uint8ClampedArray(W*H);
    const TH = (+edgeThr.value | 0) || 40;
    const TL = Math.max(0, Math.floor(TH * 0.5));

    for (let y=1;y<H-1;y++){
      let idx=y*W+1;
      for (let x=1;x<W-1;x++,idx++){
        const a=L[idx-W-1], b=L[idx-W], c=L[idx-W+1];
        const d0=L[idx-1],              f=L[idx+1];
        const g=L[idx+W-1], h=L[idx+W], i=L[idx+W+1];
        const gx = -a -2*b -c + g +2*h + i;
        const gy = -a -2*d0 -g + c +2*f + i;
        const mag = Math.abs(gx) + Math.abs(gy);
        let aa;
        if(mag>=TH) aa=255;
        else if(mag<=TL) aa=0;
        else aa=Math.round((mag-TL)/(TH-TL)*255);
        E[idx]=aa;
      }
    }
    // mask by alpha
    for (let i=0,j=0;i<d.length;i+=4,++j){
      E[j] = Math.round(E[j] * (d[i+3]/255));
    }

    edgeLayerCtx.clearRect(0,0,edgeLayerCanvas.width,edgeLayerCanvas.height);
    const [r,g,b,a01] = rgbaFrom(colorHex, alpha01);
    const mask = edgeLayerCtx.createImageData(W,H);
    const md = mask.data;

    for (let j=0,p=0;j<E.length;j++,p+=4){
      const aa = E[j];
      if(!aa){
        md[p]=md[p+1]=md[p+2]=md[p+3]=0;
        continue;
      }
      md[p]=r; md[p+1]=g; md[p+2]=b;
      md[p+3]=Math.min(255, Math.round(aa*a01));
    }
    edgeLayerCtx.putImageData(mask,0,0);

    edgeCtxOff.globalCompositeOperation='source-over';
    edgeCtxOff.drawImage(edgeLayerCanvas,0,0);
  }

  // ---------- Recall burst logic ----------
  let activeBurst = null;
  function startRandomBurst(){
    // you didn't include full burst source here in the snippet,
    // so we keep a stub to avoid runtime errors.
    // If you have your own burst frame list logic, keep it.
    if(activeBurst) return;
    // activeBurst = {frames:[...imageData...], i:0};
    // For now just create empty stub
    activeBurst = {frames:[], i:0};
  }
  function snapshotGhost(tNow){
    // stub to avoid runtime errors if you call snapshotGhost
    // (user's original code calls this to archive ghost frames)
  }

  function drawTinted(ctx, frame, color){
    // stub: in your original code you tint recall frames
    // keep empty if frame is undefined
  }

  // ---------- decay for recallCanvas each frame ----------
  function exportDecayStep(){
    const lingerS=Math.max(0.2,+recallLinger.value||1.2);
    const fade=1-Math.exp(-1/(lingerS*30));
    recallCtx.globalCompositeOperation='destination-out';
    recallCtx.fillStyle=`rgba(0,0,0,${fade})`;
    recallCtx.fillRect(0,0,can.recall.width,can.recall.height);
    recallCtx.globalCompositeOperation='source-over';
  }

  // ---------- per-frame render (preview / export both use this core) ----------
  function processOneFrame(W,H){
    // background grey
    const grey=+el.grey.value;
    fctx.clearRect(0,0,W,H);
    fctx.fillStyle=`rgb(${grey},${grey},${grey})`;
    fctx.fillRect(0,0,W,H);

    if(vid.readyState < 2){
      nosrc.hidden = false;
      return;
    } else {
      nosrc.hidden = true;
    }

    // current frame
    // preview uses contained fit
    drawVideoContained(pctx, vid, W, H, +el.preblur.value);
    const curr = pctx.getImageData(0,0,W,H);
    pushFrame(curr, vid.currentTime);

    // past frame
    const past = getPastFrame(+el.dt.value);
    if(past){
      const c = curr.data;
      const p = past.data;
      const ghostImg = gctx.createImageData(W,H);
      const gd = ghostImg.data;
      const thr = +el.thr.value;
      const mask = new Uint8ClampedArray(W*H);
      let changedCount = 0;

      for(let i=0,j=0;i<c.length;i+=4,j++){
        const r=c[i], g_=c[i+1], b=c[i+2];
        const pr=p[i], pg=p[i+1], pb=p[i+2];
        const lc = r*0.2126 + g_*0.7152 + b*0.0722;
        const lp = pr*0.2126 + pg*0.7152 + pb*0.0722;
        const d = Math.abs(lc - lp);

        if(d>thr){
          changedCount++;
          mask[j]=255;
          if(gUseColor.checked){
            const [cr,cg,cb] = hexToRgb(gColor.value);
            const a = Math.max(40, Math.min(255, (d-thr)*8));
            gd[i]=cr; gd[i+1]=cg; gd[i+2]=cb; gd[i+3]=a;
          }else{
            gd[i]   = (r + (255 - pr))*0.5;
            gd[i+1] = (g_+ (255 - pg))*0.5;
            gd[i+2] = (b +
