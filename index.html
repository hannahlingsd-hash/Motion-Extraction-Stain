<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title></title>

<style>
/* === UI ONLY — JS UNCHANGED === */
:root{
  --bg:#0b0e12;                 /* main area (canvas) stays dark */
  --accent:#ff5b5b;

  /* sidebar (light) */
  --sb-bg:#ffffff;
  --sb-fg:#111111;
  --sb-muted:#5f6672;
  --sb-border:#d0d5dd;          /* slightly deeper grey for fieldset borders */

  /* buttons (dark grey) */
  --btn-bg:#2c3138;
  --btn-fg:#ffffff;
  --btn-border:#3a4048;
  --btn-bg-2:#2c3138;           /* secondary uses same dark tone for visibility */
  --btn-fg-2:#ffffff;

  /* slider thickness */
  --track-h:4px;                /* slightly thinner */
  --thumb-d:14px;               /* handle size */
}

html,body{
  height:100%;margin:0;
  background:var(--bg);
  color:#e6eeff;                /* only affects the canvas area side */
  font:14px/1.35 Arial, Helvetica, sans-serif;
}

/* Layout */
.wrap{
  display:grid;grid-template-columns:360px 1fr;gap:14px;height:100%;
}

/* Sidebar: white with black text + thin scrollbar */
aside{
  padding:14px 12px 16px;
  border-right:1px solid var(--sb-border);
  overflow:auto;
  background:var(--sb-bg);
  color:var(--sb-fg);
  scrollbar-width:thin;                   /* Firefox */
  scrollbar-color:#c7cbd3 transparent;    /* Firefox */
}
aside::-webkit-scrollbar{width:6px;height:6px}    /* WebKit */
aside::-webkit-scrollbar-track{background:transparent}
aside::-webkit-scrollbar-thumb{background:#c7cbd3;border-radius:4px}

main{position:relative}
canvas{position:absolute;inset:0;width:100%;height:100%;object-fit:contain;background:#000}

/* (No visible title) */
aside > h1{display:none}

fieldset{
  border:1px solid var(--sb-border);
  border-radius:6px;
  margin:10px 0;
  padding:10px;
}
legend{padding:0 6px;color:#2b3240;font-weight:600}
.row{display:flex;align-items:center;gap:8px;margin:8px 0;flex-wrap:wrap}
.row label{flex:1;color:var(--sb-muted)}
.row input[type="range"], .row select{flex:2}
.small{font-size:12px;color:#6a7280}

/* Dark grey rectangular buttons */
.btn{
  appearance:none;
  border:1px solid var(--btn-border);
  background:var(--btn-bg);
  color:var(--btn-fg);
  border-radius:4px;            /* rectangular */
  padding:6px 10px;
  cursor:pointer;
  transition:filter .12s ease, transform .02s ease;
}
.btn:hover{filter:brightness(1.06)}
.btn:active{transform:translateY(1px)}
.btn.secondary{
  background:var(--btn-bg-2);
  border-color:var(--btn-border);
  color:var(--btn-fg-2);
}
.btn:disabled{opacity:.55;cursor:not-allowed}

/* File input label text */
input[type="file"]{
  font:13px Arial, Helvetica, sans-serif;
  color:var(--sb-fg);
}

/* Keyboard chip */
.kbd{
  font:12px ui-monospace, Menlo, Consolas, monospace;
  background:#f1f3f7;
  border:1px solid #dde3ea;
  border-radius:4px;
  padding:1px 6px;
  color:#2b3442;
}

/* HUD & REC badges (unchanged, dark over canvas) */
.hud{
  position:absolute;top:10px;left:10px;
  background:rgba(0,0,0,.45);padding:6px 8px;border-radius:8px;
  font:12px ui-monospace, Menlo, Consolas, monospace;white-space:pre
}
.rec{
  position:absolute;top:10px;right:10px;
  background:rgba(0,0,0,.55);padding:6px 10px;border-radius:10px;
  font:12px ui-monospace, Menlo, Consolas, monospace;display:flex;align-items:center;gap:8px
}
.dot{width:8px;height:8px;background:var(--accent);border-radius:50%;box-shadow:0 0 8px var(--accent)}
.warn{color:#cc7a2b}
.ok{color:#38a657}
.nosrc{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;color:#9aa7bd;font:12px ui-monospace;pointer-events:none}

/* Floating Replay button: rectangular dark */
.fab{
  position:absolute;top:46px;right:10px;z-index:5;
  border:1px solid var(--btn-border);
  background:var(--btn-bg);
  color:var(--btn-fg);
  border-radius:4px;
  padding:6px 10px;
  cursor:pointer
}
.fab:hover{filter:brightness(1.06)}

/* === Sliders: slightly thinner tracks === */

/* WebKit */
input[type="range"]{
  -webkit-appearance:none;appearance:none;background:transparent;height:var(--thumb-d);
}
input[type="range"]::-webkit-slider-runnable-track{
  height:var(--track-h);
  background:#e5e7ee;border-radius:999px;border:1px solid #d8dde6;
}
input[type="range"]::-webkit-slider-thumb{
  -webkit-appearance:none;margin-top:calc((var(--track-h) - var(--thumb-d))/2);
  width:var(--thumb-d);height:var(--thumb-d);
  background:#ffffff;border:1px solid #c7cdd6;border-radius:50%;
  box-shadow:0 1px 1px rgba(0,0,0,.05);
}

/* Firefox */
input[type="range"]::-moz-range-track{
  height:var(--track-h);
  background:#e5e7ee;border-radius:999px;border:1px solid #d8dde6;
}
input[type="range"]::-moz-range-thumb{
  width:var(--thumb-d);height:var(--thumb-d);
  background:#ffffff;border:1px solid #c7cdd6;border-radius:50%;
  box-shadow:0 1px 1px rgba(0,0,0,.05);
}

/* Edge/Chromium fallback */
input[type="range"]::-ms-track{
  height:var(--track-h);
  background:transparent;border-color:transparent;color:transparent;
}
input[type="range"]::-ms-fill-lower,
input[type="range"]::-ms-fill-upper{
  background:#e5e7ee;border:1px solid #d8dde6;border-radius:999px;
}
input[type="range"]::-ms-thumb{
  width:var(--thumb-d);height:var(--thumb-d);
  background:#ffffff;border:1px solid #c7cdd6;border-radius:50%;
}
</style>
</head>
<body>
<div class="wrap">
  <aside>
    <!-- (title intentionally removed) -->
    <div class="row">
      <input id="file" type="file" accept="video/*">
      <button id="webcam" class="btn">Webcam</button>
      <button id="play" class="btn secondary">Play/Pause</button>
    </div>
    <div class="row">
      <button id="replay" class="btn secondary">↺ Replay</button>
      <span class="small">Shortcut: <span class="kbd">R</span></span>
    </div>
    <div class="row small">Or URL: <span class="kbd">?src=clip.mp4</span> (same-origin or CORS)</div>

    <fieldset>
      <legend>Temporal window</legend>
      <div class="row"><label>Δt (seconds)</label><input id="dt" type="range" min="2" max="10" step="0.5" value="6"><span id="dtV">6.0</span></div>
      <div class="row"><label>Diff threshold</label><input id="thr" type="range" min="4" max="60" value="18"><span id="thrV">18</span></div>
      <div class="row"><label>Grey level</label><input id="grey" type="range" min="60" max="200" value="120"><span id="greyV">120</span></div>
      <div class="row"><label>Pre-blur (px)</label><input id="preblur" type="range" min="0" max="3" value="0"><span id="preblurV">0</span></div>
    </fieldset>

    <fieldset>
      <legend>Ghosts (motion)</legend>
      <div class="row"><label>Ghost opacity</label><input id="gAlpha" type="range" min="0" max="1" step="0.05" value="0.7"><span id="gAlphaV">0.70</span></div>
      <div class="row"><label>Blend mode</label>
        <select id="gBlend">
          <option value="normal">Normal</option>
          <option value="screen" selected>Screen</option>
          <option value="lighter">Lighter (Add)</option>
          <option value="multiply">Multiply</option>
          <option value="difference">Difference</option>
        </select>
      </div>
      <div class="row">
        <label>Use custom color</label>
        <input id="gUseColor" type="checkbox">
        <input id="gColor" type="color" value="#ffffff">
      </div>
    </fieldset>

    <fieldset>
      <legend>Stain (residual blotches)</legend>
      <div class="row"><label>Enable stain</label><input id="stainOn" type="checkbox" checked></div>
      <div class="row"><label>Decay</label><input id="decay" type="range" min="0.90" max="0.995" step="0.001" value="0.970"><span id="decayV">0.970</span></div>
      <div class="row"><label>Strength</label><input id="strength" type="range" min="0.1" max="1" step="0.05" value="0.50"><span id="strengthV">0.50</span></div>
      <div class="row"><label>Expand (px)</label><input id="expand" type="range" min="0" max="8" step="1" value="2"><span id="expandV">2</span></div>
      <div class="row"><label>Stain color</label><input id="sColor" type="color" value="#223b7a"></div>
    </fieldset>

    <fieldset>
      <legend>Recall (resurface past traces)</legend>
      <div class="row">
        <label>Enable recall</label>
        <input id="recallOn" type="checkbox">
      </div>
      <div class="row">
        <label>Recall probability</label>
        <input id="recallProb" type="range" min="0" max="1" step="0.01" value="0.20">
        <span id="recallProbV">0.20</span>
      </div>
      <div class="row">
        <label>Recall capacity</label>
        <input id="recallCap" type="range" min="0" max="120" step="5" value="40">
        <span id="recallCapV">40</span>
      </div>
      <div class="row">
        <button id="recallNow" class="btn">Recall now</button>
      </div>
      <div class="row">
        <label>Recall color</label>
        <input id="recallColor" type="color" value="#00e7ff">
      </div>
      <div class="row">
        <label>Linger (s)</label>
        <input id="recallLinger" type="range" min="0.2" max="3" step="0.1" value="1.2">
        <span id="recallLingerV">1.2</span>
      </div>
      <div class="row">
        <label>Span (s)</label>
        <input id="recallSpan" type="range" min="0" max="3" step="0.1" value="0.8">
        <span id="recallSpanV">0.8</span>
      </div>
      <div class="row small">Recalls are tinted, linger with decay, and can replay a short past span.</div>
    </fieldset>

    <fieldset>
      <legend>Export</legend>
      <div class="row">
        <label>Format</label>
        <select id="format">
          <option value="mp4">MP4 (preferred)</option>
          <option value="webm">WebM</option>
          <option value="auto" selected>Auto (best available)</option>
        </select>
      </div>
      <div class="row">
        <button id="recStart" class="btn">Start Recording</button>
        <button id="recStop" class="btn" disabled>Stop & Save</button>
      </div>
      <div class="row">
        <button id="shot" class="btn secondary">Export PNG</button>
      </div>
      <div class="row">
        <button id="exportOne" class="btn">Export 1:1 (source)</button>
        <label style="flex:none;">Match preview look</label>
        <input id="matchPreview" type="checkbox" checked>
      </div>
      <div class="row small" id="supportNote"></div>
      <div class="row small" id="dbg">buffer: 0 | fps —</div>
    </fieldset>
  </aside>

  <main>
    <canvas id="stain"></canvas>
    <canvas id="ghost"></canvas>
    <canvas id="final"></canvas>
    <div id="hud" class="hud"></div>
    <div id="recHUD" class="rec" style="display:none;"><span class="dot"></span><span id="recTime">REC 00:00</span></div>
    <div id="nosrc" class="nosrc" style="display:none;">load a clip or use the webcam</div>
    <button id="replayFloat" class="fab" title="Replay (R)">↺</button>
  </main>
</div>

<script>
(function(){
  // ---------- Elements ----------
  const can = {
    stain: document.getElementById('stain'),
    ghost: document.getElementById('ghost'),
    final: document.getElementById('final'),
  };
  const sctx = can.stain.getContext('2d');
  const gctx = can.ghost.getContext('2d');
  const fctx = can.final.getContext('2d');

  const file = document.getElementById('file');
  const webcamBtn = document.getElementById('webcam');
  const playBtn = document.getElementById('play');
  const replayBtn = document.getElementById('replay');
  const replayFloat = document.getElementById('replayFloat');
  const recStartBtn = document.getElementById('recStart');
  const recStopBtn  = document.getElementById('recStop');
  const shotBtn = document.getElementById('shot');
  const exportOneBtn = document.getElementById('exportOne');
  const matchPreview = document.getElementById('matchPreview');
  const hud = document.getElementById('hud');
  const recHUD = document.getElementById('recHUD');
  const recTime = document.getElementById('recTime');
  const dbg = document.getElementById('dbg');
  const supportNote = document.getElementById('supportNote');
  const nosrc = document.getElementById('nosrc');

  const ids = ["dt","thr","grey","preblur","gAlpha","decay","strength","expand"];
  const el  = Object.fromEntries(ids.map(id=>[id, document.getElementById(id)]));
  const out = Object.fromEntries(ids.map(id=>[id+"V", document.getElementById(id+"V")]));
  const stainOn = document.getElementById('stainOn');
  const sColor  = document.getElementById('sColor');
  const gBlend  = document.getElementById('gBlend');
  const formatSel = document.getElementById('format');
  const gUseColor = document.getElementById('gUseColor');
  const gColor    = document.getElementById('gColor');

  function sync(){
    out.dtV.textContent      = (+el.dt.value).toFixed(1);
    out.thrV.textContent     = el.thr.value;
    out.greyV.textContent    = el.grey.value;
    out.preblurV.textContent = el.preblur.value;
    out.gAlphaV.textContent  = (+el.gAlpha.value).toFixed(2);
    out.decayV.textContent   = (+el.decay.value).toFixed(3);
    out.strengthV.textContent= (+el.strength.value).toFixed(2);
    out.expandV.textContent  = el.expand.value;
  }
  [...ids.map(id=>el[id]), stainOn, sColor, gBlend, formatSel, gUseColor, gColor].forEach(x=>x.addEventListener('input', sync));
  sync();

  // ---------- Source ----------
  const vid = document.createElement('video');
  vid.crossOrigin = "anonymous";
  vid.playsInline = true; vid.muted = true; vid.loop = true; vid.preload = "auto";

  const qs = new URLSearchParams(location.search);
  const src = qs.get('src'); if(src){ vid.src = src; }

  let mediaStream = null;
  file.addEventListener('change', e=>{
    const f = e.target.files[0]; if(!f) return;
    stopWebcam();
    resetState();
    vid.src = URL.createObjectURL(f);
    vid.play();
  });
  playBtn.addEventListener('click', ()=> vid.paused ? vid.play() : vid.pause());

  webcamBtn.addEventListener('click', ()=> startWebcam().catch(e=>alert('Webcam failed: '+(e && e.message ? e.message : e))));

  async function startWebcam(){
    const secure = (location.protocol === 'https:' ||
                    location.hostname === 'localhost' ||
                    location.hostname === '127.0.0.1');
    if (!secure) {
      throw new Error('Camera requires HTTPS or localhost. Serve this page over https:// or run on localhost.');
    }
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      throw new Error('getUserMedia is not available in this browser.');
    }

    stopWebcam();
    resetState();

    const tries = [
      { video: { facingMode: { ideal: 'environment' }, width: { ideal: 1280 }, height: { ideal: 720 } }, audio: false },
      { video: true, audio: false }
    ];

    let errLast = null;
    for (const constraints of tries) {
      try {
        mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
        break;
      } catch (err) {
        errLast = err;
        mediaStream = null;
      }
    }
    if (!mediaStream) {
      if (errLast && (errLast.name === 'NotAllowedError' || errLast.name === 'SecurityError')) {
        throw new Error('Camera permission was blocked. Check Site Settings → Camera and allow access.');
      }
      if (errLast && errLast.name === 'NotFoundError') {
        throw new Error('No camera device found.');
      }
      throw errLast || new Error('Unable to access camera.');
    }

    vid.srcObject = mediaStream;
    await new Promise(res => {
      if (vid.readyState >= 1) return res();
      vid.addEventListener('loadedmetadata', res, { once: true });
    });

    try { await vid.play(); } catch (e) {
      throw new Error('Camera stream ready but autoplay failed. Click Play or allow autoplay for this site.');
    }
  }

  function stopWebcam(){
    if(mediaStream){
      try { mediaStream.getTracks().forEach(t=>t.stop()); } catch(_){}
      mediaStream = null;
    }
    if (vid && vid.srcObject) {
      try { vid.srcObject = null; } catch(_){}
    }
  }

  // ---------- HiDPI sizing ----------
  const proc = document.createElement('canvas');
  const pctx = proc.getContext('2d', {willReadFrequently:true});
  const maskCanvas = document.createElement('canvas');
  const maskCtx = maskCanvas.getContext('2d');
  const colCanvas = document.createElement('canvas');
  const colCtx = colCanvas.getContext('2d');

  // NEW: offscreen canvas for lingering recalls
  const recallCanvas = document.createElement('canvas');
  const recallCtx = recallCanvas.getContext('2d');

  function fit(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const r = can.final.getBoundingClientRect();
    const W = Math.max(2, Math.round(r.width*dpr));
    const H = Math.max(2, Math.round(r.height*dpr));
    for(const k in can){ can[k].width=W; can[k].height=H; }
    proc.width=W; proc.height=H;
    maskCanvas.width=W; maskCanvas.height=H;
    colCanvas.width=W; colCanvas.height=H;
    recallCanvas.width=W; recallCanvas.height=H;
  }
  new ResizeObserver(fit).observe(can.final);
  fit(); // initial size

  // ---------- Buffers ----------
  const buf = []; const MAX_SEC = 14;
  function pushFrame(img, t){
    buf.push({t, data: new Uint8ClampedArray(img.data), w: img.width, h: img.height});
    const cutoff = t - (MAX_SEC + 2);
    while(buf.length && buf[0].t < cutoff) buf.shift();
  }
  function getPastFrame(delta){
    const target = vid.currentTime - delta;
    for(let i=buf.length-1;i>=0;i--){ if(buf[i].t <= target) return buf[i]; }
    return buf[0] || null;
  }

  function drawVideoContained(ctx, video, W, H, blurPx){
    ctx.save();
    ctx.clearRect(0,0,W,H);
    if(blurPx>0) ctx.filter = `blur(${blurPx}px)`;
    const vw=video.videoWidth||0, vh=video.videoHeight||0;
    if(vw && vh){
      const s = Math.min(W/vw, H/vh);
      const dw = Math.round(vw*s), dh = Math.round(vh*s);
      const dx = Math.floor((W-dw)/2), dy = Math.floor((H-dh)/2);
      ctx.drawImage(video, dx,dy,dw,dh);
    }
    ctx.restore();
  }

  // ---------- Recording ----------
  let recorder=null, chunks=[], recStartTime=0, recTimer=null, recMime="", recExt="webm";
  function bestSupported(){
    const mp4='video/mp4;codecs=avc1.42E01E,mp4a.40.2';
    const webm='video/webm;codecs=vp9,opus';
    const webm2='video/webm;codecs=vp8,opus';
    const canMp4 = !!(window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(mp4));
    const canWebm= !!(window.MediaRecorder && MediaRecorder.isTypeSupported && (MediaRecorder.isTypeSupported(webm)||MediaRecorder.isTypeSupported(webm2)));
    return {canMp4, canWebm, mp4, webm:(MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(webm)?webm:webm2)};
  }
  function refreshSupportNote(){
    const s=bestSupported();
    const fmt=document.getElementById('format').value;
    let msg='';
    if(fmt==='mp4'){ msg = s.canMp4 ? '<span class="ok">MP4 recording supported ✓</span>' : '<span class="warn">MP4 not supported here. Use Safari/WebKit or switch to WebM.</span>'; }
    else if(fmt==='webm'){ msg = s.canWebm ? 'WebM recording supported ✓' : '<span class="warn">WebM not supported.</span>'; }
    else { msg = s.canMp4 ? 'Auto → MP4' : (s.canWebm ? 'Auto → WebM' : '<span class="warn">Recording unsupported.</span>'); }
    supportNote.innerHTML = msg;
  }
  refreshSupportNote();
  document.getElementById('format').addEventListener('change', refreshSupportNote);

  function startRecording(){
    const s=bestSupported(); const sel=document.getElementById('format').value;
    let mime='';
    if(sel==='mp4') mime = s.canMp4 ? s.mp4 : '';
    else if(sel==='webm') mime = s.canWebm ? s.webm : '';
    else mime = s.canMp4 ? s.mp4 : (s.canWebm ? s.webm : '');
    if(!mime){ alert('Recording format not supported on this browser.'); return; }

    const stream = can.final.captureStream ? can.final.captureStream(30) : can.final.mozCaptureStream(30);
    chunks=[];
    recorder = new MediaRecorder(stream, {mimeType:mime, videoBitsPerSecond: 8_000_000});
    recMime=mime; recExt = mime.startsWith('video/mp4') ? 'mp4' : 'webm';
    recorder.ondataavailable = e=>{ if(e.data && e.data.size) chunks.push(e.data); };
    recorder.onstop = ()=>{
      const blob = new Blob(chunks, {type: recMime});
      const a = document.createElement('a');
      a.download = `wind_on_wall_${Date.now()}.${recExt}`;
      a.href = URL.createObjectURL(blob);
      a.click();
      stopRecUI();
    };
    recorder.start(250);

    recStartTime = performance.now();
    recTimer = setInterval(()=>{
      const t = Math.floor((performance.now()-recStartTime)/1000);
      const mm = String(Math.floor(t/60)).padStart(2,'0');
      const ss = String(t%60).padStart(2,'0');
      recTime.textContent = `REC ${mm}:${ss}`;
    },250);
    recHUD.style.display='flex';
    recStartBtn.disabled=true; recStopBtn.disabled=false;
  }
  function stopRecording(){ if(recorder && recorder.state==='recording'){ recorder.stop(); } }
  function stopRecUI(){ clearInterval(recTimer); recTimer=null; recHUD.style.display='none'; recStartBtn.disabled=false; recStopBtn.disabled=true; }
  recStartBtn.addEventListener('click', startRecording);
  recStopBtn.addEventListener('click',  stopRecording);

  shotBtn.addEventListener('click', ()=>{
    const a = document.createElement('a');
    a.download = 'still_'+Date.now()+'.png';
    a.href = can.final.toDataURL('image/png');
    a.click();
  });

  // ---------- Replay ----------
  function resetState(){
    buf.length = 0;
    sctx.clearRect(0,0,can.stain.width,can.stain.height);
    gctx.clearRect(0,0,can.ghost.width,can.ghost.height);
    recallBank.length = 0;
    recallCtx.clearRect(0,0,recallCanvas.width,recallCanvas.height);
    activeBurst = null;
  }
  function replay(){
    if(vid.srcObject){
      alert('Replay is for file/URL clips. Stop Webcam and load a clip to use Replay.');
      return;
    }
    if(!vid.currentSrc && !vid.src){ alert('No clip loaded.'); return; }
    if(recorder && recorder.state==='recording'){ stopRecording(); }
    try{
      vid.pause();
      resetState();
      const onSeeked = () => { vid.removeEventListener('seeked', onSeeked); vid.play(); };
      vid.addEventListener('seeked', onSeeked, { once:true });
      vid.currentTime = 0;
    }catch(e){
      const src = vid.currentSrc || vid.src;
      if(src){ resetState(); vid.src = src; vid.play(); }
    }
  }
  replayBtn.addEventListener('click', replay);
  replayFloat.addEventListener('click', replay);
  document.addEventListener('keydown', (e)=>{
    const t = e.target;
    if(t && (t.tagName==='INPUT' || t.tagName==='SELECT' || t.tagName==='TEXTAREA' || t.isContentEditable)) return;
    if(e.code === 'KeyR'){ e.preventDefault(); replay(); }
    else if(e.code === 'Space'){ e.preventDefault(); vid.paused ? vid.play() : vid.pause(); }
  });

  // ---------- Helpers ----------
  function hexToRgb(hex){
    const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return m ? [parseInt(m[1],16), parseInt(m[2],16), parseInt(m[3],16)] : [255,255,255];
  }
  function parseHex3(hex){
    const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex||'#ffffff');
    return m ? [parseInt(m[1],16), parseInt(m[2],16), parseInt(m[3],16)] : [255,255,255];
  }

  // ---------- Recall module ----------
  const recallOn     = document.getElementById('recallOn');
  const recallProb   = document.getElementById('recallProb');
  const recallProbV  = document.getElementById('recallProbV');
  const recallCap    = document.getElementById('recallCap');
  const recallCapV   = document.getElementById('recallCapV');
  const recallNowB   = document.getElementById('recallNow');
  const recallColor  = document.getElementById('recallColor');
  const recallLinger = document.getElementById('recallLinger');
  const recallLingerV= document.getElementById('recallLingerV');
  const recallSpan   = document.getElementById('recallSpan');
  const recallSpanV  = document.getElementById('recallSpanV');

  function syncRecall(){
    if (recallProbV)   recallProbV.textContent   = (+recallProb.value).toFixed(2);
    if (recallCapV)    recallCapV.textContent    = recallCap.value;
    if (recallLingerV) recallLingerV.textContent = (+recallLinger.value).toFixed(1);
    if (recallSpanV)   recallSpanV.textContent   = (+recallSpan.value).toFixed(1);
  }
  [recallOn, recallProb, recallCap, recallColor, recallLinger, recallSpan]
    .forEach(x=>x && x.addEventListener('input', syncRecall));
  syncRecall();

  // Store ghost frames with timestamps for span selection
  const recallBank = []; // {img: ImageBitmap|Canvas, t: number}
  let recallBurst = 0;
  let activeBurst = null; // {frames:[img,...], i:number}

  function capRecallBank(max){
    while(recallBank.length > max) recallBank.shift();
  }

  async function snapshotGhost(tNow){
    try {
      let img;
      if ('createImageBitmap' in window) img = await createImageBitmap(can.ghost);
      else {
        const c = document.createElement('canvas');
        c.width = can.ghost.width; c.height = can.ghost.height;
        c.getContext('2d').drawImage(can.ghost,0,0);
        img = c;
      }
      recallBank.push({img, t: tNow});
      capRecallBank((+recallCap.value|0) || 40);
    } catch(_){}
  }

  function startRandomBurst(){
    if (!recallBank.length) return;
    const span = Math.max(0, +recallSpan.value || 0);
    const r = (Math.random()*recallBank.length)|0;
    const t0 = recallBank[r].t, t1 = t0 + span;

    const frames = recallBank
      .filter(f => f.t >= t0 && f.t <= t1)
      .map(f => f.img);

    activeBurst = { frames: frames.length ? frames : [recallBank[r].img], i: 0 };
  }

  if (recallNowB) {
    recallNowB.addEventListener('click', ()=>{
      recallBurst += 1;
    });
  }

  function drawTinted(dstCtx, src, color){
    // draw frame silhouette
    dstCtx.globalCompositeOperation = 'source-over';
    dstCtx.drawImage(src, 0, 0);
    // tint through mask
    dstCtx.globalCompositeOperation = 'source-in';
    dstCtx.fillStyle = color || '#00e7ff';
    dstCtx.fillRect(0,0,recallCanvas.width, recallCanvas.height);
    // restore
    dstCtx.globalCompositeOperation = 'source-over';
  }

  // ---------- Main loop ----------
  let lastT=performance.now(), fpsEMA=0, suspendLive=false;
  requestAnimationFrame(function tick(now){
    requestAnimationFrame(tick);
    if (suspendLive) return;

    const W = can.final.width, H = can.final.height;

    // base
    const grey = +el.grey.value;
    fctx.clearRect(0,0,W,H);
    fctx.fillStyle = `rgb(${grey},${grey},${grey})`;
    fctx.fillRect(0,0,W,H);

    if(vid.readyState < 2){
      nosrc.style.display = 'block';
      return;
    } else {
      nosrc.style.display = 'none';
    }

    // 1) current frame → analysis
    drawVideoContained(pctx, vid, W, H, +el.preblur.value);
    const curr = pctx.getImageData(0,0,W,H);
    pushFrame(curr, vid.currentTime);

    // 2) past frame
    const past = getPastFrame(+el.dt.value);
    if(!past){ return; }

    // 3) motion mask + ghosts
    const c = curr.data, p = past.data;
    const ghostImg = gctx.createImageData(W,H);
    const gd = ghostImg.data;
    const thr = +el.thr.value;
    const mask = new Uint8ClampedArray(W*H);
    let changedCount=0;

    for(let i=0,j=0;i<c.length;i+=4,j++){
      const r=c[i], g=c[i+1], b=c[i+2];
      const pr=p[i], pg=p[i+1], pb=p[i+2];
      const lc = r*0.2126 + g*0.7152 + b*0.0722;
      const lp = pr*0.2126 + pg*0.7152 + pb*0.0722;
      const d = Math.abs(lc - lp);

      if(d > thr){
        changedCount++; mask[j]=255;

        if (gUseColor.checked) {
          const [cr,cg,cb] = hexToRgb(gColor.value);
          const a = Math.max(40, Math.min(255, (d - thr) * 8));
          gd[i]=cr; gd[i+1]=cg; gd[i+2]=cb; gd[i+3]=a;
        } else {
          gd[i]   = (r + (255 - pr)) * 0.5;
          gd[i+1] = (g + (255 - pg)) * 0.5;
          gd[i+2] = (b + (255 - pb)) * 0.5;
          gd[i+3] = 255;
        }
      } else {
        gd[i]=gd[i+1]=gd[i+2]=0; gd[i+3]=0;
      }
    }
    gctx.putImageData(ghostImg,0,0);

    // 4) stain accumulation
    if(stainOn.checked){
      const decay = +el.decay.value;
      sctx.globalCompositeOperation='destination-out';
      sctx.fillStyle = `rgba(0,0,0,${1-decay})`;
      sctx.fillRect(0,0,W,H);
      sctx.globalCompositeOperation='source-over';

      const mImg = maskCtx.createImageData(W,H);
      const mdat = mImg.data;
      for(let j=0,k=0;j<mask.length;j++,k+=4){
        const v = mask[j]; mdat[k]=mdat[k+1]=mdat[k+2]=v; mdat[k+3]=v;
      }
      maskCtx.putImageData(mImg,0,0);

      colCtx.clearRect(0,0,W,H);
      const expand = +el.expand.value;
      if(expand>0){ colCtx.filter = `blur(${expand}px)`; }
      colCtx.drawImage(maskCanvas,0,0);
      colCtx.filter='none';
      colCtx.globalCompositeOperation='source-in';
      colCtx.fillStyle = sColor.value;
      colCtx.globalAlpha = +el.strength.value;
      colCtx.fillRect(0,0,W,H);
      colCtx.globalCompositeOperation='source-over';
      colCtx.globalAlpha = 1;
      sctx.drawImage(colCanvas,0,0);
    }

    // 5) compose: base grey → stain (multiply) → ghosts
    if(stainOn.checked){
      fctx.globalCompositeOperation='multiply';
      fctx.drawImage(can.stain,0,0);
      fctx.globalCompositeOperation='source-over';
    }
    fctx.globalAlpha = +el.gAlpha.value;
    fctx.globalCompositeOperation = gBlend.value;
    fctx.drawImage(can.ghost,0,0);
    fctx.globalAlpha = 1;
    fctx.globalCompositeOperation='source-over';

    // === Recall capture + random burst + lingering ===

    // Capture any frame with motion
    if (changedCount > 0) {
      snapshotGhost(vid.currentTime); // async
    }

    // Maybe start a random burst
    if (recallOn && recallOn.checked) {
      const prob = +recallProb.value || 0;
      if (Math.random() < prob && !activeBurst) startRandomBurst();
    }

    // Linger decay on recallCanvas (time-based)
    {
      const lingerS = Math.max(0.2, +recallLinger.value || 1.2);
      const ms = Math.max(1, now - lastT);
      const fade = 1 - Math.exp(-ms / (lingerS * 1000)); // 0..1 per-frame clearing
      recallCtx.globalCompositeOperation = 'destination-out';
      recallCtx.fillStyle = `rgba(0,0,0,${fade})`;
      recallCtx.fillRect(0,0,recallCanvas.width, recallCanvas.height);
      recallCtx.globalCompositeOperation = 'source-over';
    }

    // If a burst is active, composite next frame tinted into recallCanvas
    if (activeBurst && activeBurst.frames && activeBurst.frames.length){
      const color = recallColor ? recallColor.value : '#00e7ff';
      drawTinted(recallCtx, activeBurst.frames[activeBurst.i], color);
      activeBurst.i++;
      if (activeBurst.i >= activeBurst.frames.length) activeBurst = null;
    }

    // Forced recalls
    if (recallBurst > 0) {
      startRandomBurst();
      recallBurst -= 1;
    }

    // Composite lingering recalls over final image
    fctx.globalCompositeOperation = 'screen';
    fctx.globalAlpha = 1;
    fctx.drawImage(recallCanvas, 0, 0);
    fctx.globalCompositeOperation = 'source-over';

    // HUD
    const dt = now - lastT; lastT = now;
    const inst = dt>0 ? 1000/dt : 0; fpsEMA = fpsEMA? fpsEMA*0.9 + inst*0.1 : inst;
    const pct = 100*(changedCount/(W*H));
    hud.textContent = `Δt = ${(+el.dt.value).toFixed(1)} s
thr = ${el.thr.value}, pre-blur = ${el.preblur.value}, grey = ${el.grey.value}
ghost: ${gBlend.value}, α=${(+el.gAlpha.value).toFixed(2)}${gUseColor.checked?`, color=${gColor.value}`:''}
stain: decay=${(+el.decay.value).toFixed(3)}, expand=${el.expand.value}, strength=${(+el.strength.value).toFixed(2)}
changed = ${pct.toFixed(1)}%`;

    const s = bestSupported();
    dbg.textContent = `buffer: ${buf.length} | fps ~ ${fpsEMA.toFixed(1)} | support: ${s.canMp4?'MP4✓':'MP4×'}/${s.canWebm?'WebM✓':'WebM×'}`;
  });

  vid.addEventListener('loadeddata', ()=>{ vid.play().catch(()=>{}); });

  // ---------- Export 1:1 (source) ----------
  exportOneBtn.addEventListener('click', exportSourceOnce);

  async function exportSourceOnce(){
    if(vid.srcObject){ alert('1:1 export is for file/URL clips, not webcam.'); return; }
    if(!(vid.currentSrc || vid.src)){ alert('Load a clip first.'); return; }

    if(vid.readyState < 1){
      await new Promise(res=>vid.addEventListener('loadedmetadata', res, {once:true}));
    }
    const vw = vid.videoWidth|0, vh = vid.videoHeight|0;
    if(!vw || !vh){ alert('Video metadata unavailable.'); return; }

    const s=bestSupported();
    const sel=formatSel.value;
    let mime='', ext='webm';
    if(sel==='mp4'){ if(s.canMp4){ mime=s.mp4; ext='mp4'; } }
    else if(sel==='webm'){ if(s.canWebm){ mime=s.webm; ext='webm'; } }
    else { if(s.canMp4){ mime=s.mp4; ext='mp4'; } else if(s.canWebm){ mime=s.webm; ext='webm'; } }
    if(!mime){ alert('Export not supported on this browser. Try Safari (MP4) or Chrome/Firefox (WebM).'); return; }

    exportOneBtn.disabled = true;
    recStartBtn.disabled = true;
    const prevSuspend = suspendLive; suspendLive = true;

    const outCanvas = document.createElement('canvas');
    outCanvas.width = vw; outCanvas.height = vh;
    const octx = outCanvas.getContext('2d');

    const expChunks = [];
    const stream = outCanvas.captureStream ? outCanvas.captureStream(30) : outCanvas.mozCaptureStream(30);
    const expRecorder = new MediaRecorder(stream, {mimeType:mime, videoBitsPerSecond: 8_000_000});
    const recDone = new Promise(resolve=>{
      expRecorder.ondataavailable = e=>{ if(e.data && e.data.size) expChunks.push(e.data); };
      expRecorder.onstop = resolve;
    });

    const prev = { loop: vid.loop, rate: vid.playbackRate, paused: vid.paused, t: vid.currentTime };
    resetState();
    vid.pause(); vid.loop = false; vid.playbackRate = 1;

    const nativeProcessing = !matchPreview.checked;
    const prevSizes = {
      W: can.final.width, H: can.final.height,
      sW: can.stain.width, sH: can.stain.height,
      gW: can.ghost.width, gH: can.ghost.height,
      pW: proc.width, pH: proc.height,
      mW: maskCanvas.width, mH: maskCanvas.height,
      cW: colCanvas.width, cH: colCanvas.height
    };
    if (nativeProcessing) {
      [can.stain, can.ghost, can.final, proc, maskCanvas, colCanvas].forEach(c=>{ c.width = vw; c.height = vh; });
      recallCanvas.width = vw; recallCanvas.height = vh; // align recall layer to export size
      recallCtx.clearRect(0,0,recallCanvas.width,recallCanvas.height);
    }

    function drawContain(srcCanvas, dstCtx, dstW, dstH){
      const sw = srcCanvas.width, sh = srcCanvas.height;
      const s = Math.min(dstW/sw, dstH/sh);
      const dw = Math.round(sw*s), dh = Math.round(sh*s);
      const dx = Math.floor((dstW-dw)/2), dy = Math.floor((dstH-dh)/2);
      dstCtx.clearRect(0,0,dstW,dstH);
      dstCtx.drawImage(srcCanvas, dx, dy, dw, dh);
    }
    function blitToOut(){
      if (matchPreview.checked) drawContain(can.final, octx, vw, vh);
      else { octx.clearRect(0,0,vw,vh); octx.drawImage(can.final, 0, 0, vw, vh); }
    }

    // Fixed per-frame decay for export (assume 30fps)
    function exportDecayStep(){
      const lingerS = Math.max(0.2, +recallLinger.value || 1.2);
      const fade = 1 - Math.exp(-1 / (lingerS * 30));
      recallCtx.globalCompositeOperation = 'destination-out';
      recallCtx.fillStyle = `rgba(0,0,0,${fade})`;
      recallCtx.fillRect(0,0,recallCanvas.width, recallCanvas.height);
      recallCtx.globalCompositeOperation = 'source-over';
    }

    function processOneFrame(W,H){
      const grey = +el.grey.value;
      fctx.clearRect(0,0,W,H);
      fctx.fillStyle = `rgb(${grey},${grey},${grey})`;
      fctx.fillRect(0,0,W,H);

      drawVideoContained(pctx, vid, W, H, +el.preblur.value);
      const curr = pctx.getImageData(0,0,W,H);
      pushFrame(curr, vid.currentTime);

      const past = getPastFrame(+el.dt.value);
      if(past){
        const c = curr.data, p = past.data;
        const ghostImg = gctx.createImageData(W,H);
        const gd = ghostImg.data;
        const thr = +el.thr.value;
        const mask = new Uint8ClampedArray(W*H);

        for(let i=0,j=0;i<c.length;i+=4,j++){
          const r=c[i], g=c[i+1], b=c[i+2];
          const pr=p[i], pg=p[i+1], pb=p[i+2];
          const lc = r*0.2126 + g*0.7152 + b*0.0722;
          const lp = pr*0.2126 + pg*0.7152 + pb*0.0722;
          const d  = Math.abs(lc - lp);

          if(d > thr){
            mask[j]=255;
            if (gUseColor.checked) {
              const m=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(gColor.value);
              const cr=m?parseInt(m[1],16):255, cg=m?parseInt(m[2],16):255, cb=m?parseInt(m[3],16):255;
              const a = Math.max(40, Math.min(255, (d - thr) * 8));
              gd[i]=cr; gd[i+1]=cg; gd[i+2]=cb; gd[i+3]=a;
            } else {
              gd[i]   = (r + (255 - pr)) * 0.5;
              gd[i+1] = (g + (255 - pg)) * 0.5;
              gd[i+2] = (b + (255 - pb)) * 0.5;
              gd[i+3] = 255;
            }
          } else {
            gd[i]=gd[i+1]=gd[i+2]=0; gd[i+3]=0;
          }
        }
        gctx.putImageData(ghostImg,0,0);

        if(stainOn.checked){
          const decay = +el.decay.value;
          sctx.globalCompositeOperation='destination-out';
          sctx.fillStyle = `rgba(0,0,0,${1-decay})`;
          sctx.fillRect(0,0,W,H);
          sctx.globalCompositeOperation='source-over';

          const mImg = maskCtx.createImageData(W,H);
          const mdat = mImg.data;
          for(let j=0,k=0;j<mask.length;j++,k+=4){
            const v = mask[j]; mdat[k]=mdat[k+1]=mdat[k+2]=v; mdat[k+3]=v;
          }
          maskCtx.putImageData(mImg,0,0);

          colCtx.clearRect(0,0,W,H);
          const expand = +el.expand.value;
          if(expand>0){ colCtx.filter = `blur(${expand}px)`; }
          colCtx.drawImage(maskCanvas,0,0);
          colCtx.filter='none';
          colCtx.globalCompositeOperation='source-in';
          colCtx.fillStyle = sColor.value;
          colCtx.globalAlpha = +el.strength.value;
          colCtx.fillRect(0,0,W,H);
          colCtx.globalCompositeOperation='source-over';
          colCtx.globalAlpha = 1;
          sctx.drawImage(colCanvas,0,0);
        }
      }

      if(stainOn.checked){
        fctx.globalCompositeOperation='multiply';
        fctx.drawImage(can.stain,0,0);
        fctx.globalCompositeOperation='source-over';
      }
      fctx.globalAlpha = +el.gAlpha.value;
      fctx.globalCompositeOperation = gBlend.value;
      fctx.drawImage(can.ghost,0,0);
      fctx.globalAlpha = 1;
      fctx.globalCompositeOperation='source-over';

      // Export-path recall logic (deterministic per-frame)
      // Capture when motion exists
      if (vid && !isNaN(vid.currentTime)) {
        // simple heuristic: always snapshot; export is offline anyway
        snapshotGhost(vid.currentTime);
      }
      // Maybe start burst per probability
      if (recallOn && recallOn.checked) {
        const prob = +recallProb.value || 0;
        if (Math.random() < prob && !activeBurst) startRandomBurst();
      }
      // Linger decay (fixed per-frame)
      exportDecayStep();
      // Draw next frame of burst
      if (activeBurst && activeBurst.frames && activeBurst.frames.length){
        const color = recallColor ? recallColor.value : '#00e7ff';
        drawTinted(recallCtx, activeBurst.frames[activeBurst.i], color);
        activeBurst.i++;
        if (activeBurst.i >= activeBurst.frames.length) activeBurst = null;
      }
      // Forced recalls queued
      if (recallBurst > 0) { startRandomBurst(); recallBurst -= 1; }
      // Composite lingering recalls
      fctx.globalCompositeOperation = 'screen';
      fctx.drawImage(recallCanvas,0,0);
      fctx.globalCompositeOperation = 'source-over';
    }

    await new Promise(res=>{ const h=()=>{vid.removeEventListener('seeked',h); res();}; vid.addEventListener('seeked',h); try{ vid.currentTime=0; }catch(_){ res(); } });
    const stream = outCanvas.captureStream ? outCanvas.captureStream(30) : outCanvas.mozCaptureStream(30);
    const expRecorder = new MediaRecorder(stream, {mimeType:mime, videoBitsPerSecond: 8_000_000});
    expRecorder.ondataavailable = e=>{ if(e.data && e.data.size) expChunks.push(e.data); };
    const recDone = new Promise(resolve=>{ expRecorder.onstop = resolve; });

    expRecorder.start(250);
    processOneFrame(can.final.width, can.final.height);
    blitToOut();

    const hasVFC = typeof vid.requestVideoFrameCallback === 'function';
    let vfcId=null, rafId=null;
    function stopDrivers(){ if(vfcId && vid.cancelVideoFrameCallback) try{vid.cancelVideoFrameCallback(vfcId);}catch(_){}
                            if(rafId) cancelAnimationFrame(rafId); vfcId=rafId=null; }
    function loop(){ processOneFrame(can.final.width, can.final.height); blitToOut();
                     if(hasVFC) vfcId = vid.requestVideoFrameCallback(()=>loop());
                     else rafId = requestAnimationFrame(loop); }

    const safety = setTimeout(()=>{ try{ vid.pause(); }catch(_){}; finalize(); }, (isFinite(vid.duration)?vid.duration:60)*1000 + 15000);
    function finalize(){ clearTimeout(safety); stopDrivers(); try{ expRecorder.stop(); }catch(_){} }

    vid.addEventListener('ended', finalize, {once:true});
    await vid.play().catch(()=>{});
    loop();
    await recDone;

    const blob = new Blob(expChunks, {type: mime});
    const a = document.createElement('a');
    const tag = matchPreview.checked ? 'match' : 'native';
    a.download = `wind_on_wall_1x_${vw}x${vh}_${tag}_${Date.now()}.${ext}`;
    a.href = URL.createObjectURL(blob);
    a.click();

    if (nativeProcessing) {
      can.final.width = prevSizes.W; can.final.height = prevSizes.H;
      can.stain.width = prevSizes.sW; can.stain.height = prevSizes.sH;
      can.ghost.width = prevSizes.gW; can.ghost.height = prevSizes.gH;
      proc.width=prevSizes.pW; proc.height=prevSizes.pH;
      maskCanvas.width=prevSizes.mW; maskCanvas.height=prevSizes.mH;
      colCanvas.width=prevSizes.cW; colCanvas.height=prevSizes.cH;
      // keep recallCanvas as-is; will be resized by fit() on next layout
    }
    vid.loop = prev.loop; vid.playbackRate = prev.rate;
    try{ vid.currentTime = prev.t; }catch(_){}
    if(!prev.paused){ try{ await vid.play(); }catch(_){ } }
    suspendLive = prevSuspend;
    exportOneBtn.disabled = false;
    recStartBtn.disabled = false;
  }
})();
</script>
</body>
</html>
