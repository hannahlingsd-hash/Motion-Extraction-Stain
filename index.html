<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Wind-on-Wall — Ghosts + Stain (hi-res)</title>

<style>
  :root{
    --bg:#fff; --fg:#000; --mut:#333; --line:#000;
    --colR:320px;
    --track-fill:#111;
    --track-bg:#cfcfcf;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font:13px/1.45 Arial, Helvetica, sans-serif}
  body{overflow:hidden;}
  *{box-sizing:border-box;border-radius:0}
  button,input,select,label{font:inherit;color:var(--fg);background:#fff;margin:0}

  .wrap{
    display:grid;
    grid-template-columns: minmax(0,1fr) var(--colR);
    gap:16px; height:100vh; padding:12px; overflow:hidden;
  }
  main{position:relative;display:flex;align-items:center;justify-content:center;min-width:0}
  .stage{
    position:relative;
    width:100%;
    height:100%;
    aspect-ratio:16/9;
    background:#fff;
    overflow:hidden;
  }
  canvas{
    position:absolute; inset:0;
    width:100%; height:100%;
    object-fit:contain;
    background:#000;
    border:0; outline:0; box-shadow:none; display:block;
    transform:translateZ(0.001px);
  }

  aside.panel{padding-top:4px; padding-right:14px; padding-left:4px; overflow:auto; scrollbar-width:thin}
  aside.panel::-webkit-scrollbar{width:10px}
  aside.panel::-webkit-scrollbar-thumb{background:#bbb}
  aside.panel::-webkit-scrollbar-track{background:#eee}

  .group{font-weight:700;margin:18px 0 6px}
  .row{display:grid;align-items:center;gap:8px;margin:6px 0;grid-template-columns:1fr minmax(120px,1.6fr) 44px}
  .row.compact{grid-template-columns:1fr auto 44px}
  .row > span{text-align:right;color:#000}
  .row label{color:var(--fg)}

  .row.colorop{
    grid-template-columns: 1fr auto 110px 44px !important;
  }
  .row.colorop input[type="range"]{
    width:110px !important;
    max-width:110px !important;
    justify-self:start;
  }

  .btnRow{display:flex;gap:8px;flex-wrap:wrap;margin:6px 0}
  .inlineRow{display:flex;align-items:center;gap:8px;margin:6px 0}

  .exportGrid{display:grid;gap:8px;margin:6px 0;grid-template-columns:1fr 1fr 1fr}
  .exportGrid .full{grid-column:1 / -1}

  .btn{appearance:none;background:#fff;color:#000;border:1px solid var(--line);padding:6px 10px;cursor:pointer}
  .btn.secondary{background:#fff}
  .btn:disabled{opacity:.5;cursor:not-allowed}

  input[type="range"]{appearance:none;height:2px;outline:none;background:linear-gradient(to right,var(--track-fill) 0 var(--p,0%),var(--track-bg) var(--p,0%) 100%)}
  input[type="range"]::-webkit-slider-thumb{appearance:none;width:10px;height:10px;background:#000;border:1px solid #000}
  input[type="range"]::-moz-range-thumb{width:10px;height:10px;background:#000;border:1px solid #000}
  input[type="range"]::-moz-range-track{height:2px;background:var(--track-bg)}
  input[type="range"]::-moz-range-progress{height:2px;background:var(--track-fill)}

  input[type="color"]{width:32px;height:22px;border:1px solid #000;background:#fff;padding:0}

  .hud{display:none!important}
  .rec{position:absolute;top:10px;right:10px;background:rgba(0,0,0,.6);color:#fff;padding:6px 10px;display:flex;align-items:center;gap:8px}
  .dot{width:8px;height:8px;background:#ff5b5b}
  .nosrc{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;color:#888;font:12px ui-monospace;pointer-events:none}
  .fab{display:none}
  .small{font-size:12px;color:#333}
</style>
</head>

<body>
<div class="wrap">
  <main>
    <div class="stage">
      <canvas id="stain"></canvas>
      <canvas id="ghost"></canvas>
      <canvas id="final"></canvas>
      <div id="hud" class="hud"></div>
      <div id="recHUD" class="rec" style="display:none;"><span class="dot"></span><span id="recTime">REC 00:00</span></div>
      <div id="nosrc" class="nosrc" style="display:none;">load a clip or use the webcam</div>
      <button id="replayFloat" class="fab" title="Replay (R)">↺</button>
    </div>
  </main>

  <aside class="panel">
    <div class="group">Source</div>
    <div class="btnRow">
      <input id="file" type="file" accept="video/*">
    </div>
    <div class="btnRow">
      <button id="webcam" class="btn">Webcam</button>
      <button id="play" class="btn secondary">Play/Pause</button>
      <button id="replay" class="btn secondary">Replay</button>
    </div>

    <div class="group">Temporal window</div>
    <div class="row"><label>Δt (seconds)</label><input id="dt" type="range" min="2" max="10" step="0.5" value="6"><span id="dtV">6.0</span></div>
    <div class="row"><label>Diff threshold</label><input id="thr" type="range" min="4" max="60" value="60"><span id="thrV">60</span></div>
    <div class="row"><label>Grey level</label><input id="grey" type="range" min="60" max="200" value="200"><span id="greyV">200</span></div>
    <div class="row"><label>Pre-blur (px)</label><input id="preblur" type="range" min="0" max="3" value="0"><span id="preblurV">0</span></div>

    <div class="group">Ghosts</div>
    <div class="row"><label>Ghost opacity</label><input id="gAlpha" type="range" min="0" max="1" step="0.05" value="0.75"><span id="gAlphaV">0.75</span></div>
    <div class="row">
      <label>Blend mode</label>
      <select id="gBlend">
        <option value="normal" selected>Normal</option>
        <option value="screen">Screen</option>
        <option value="lighter">Lighter (Add)</option>
        <option value="multiply">Multiply</option>
        <option value="difference">Difference</option>
      </select>
      <span></span>
    </div>
    <div class="row compact">
      <label>Ghost color</label>
      <input id="gUseColor" type="checkbox" checked style="display:none">
      <input id="gColor" type="color" value="#000000">
    </div>

    <div class="group">Stain</div>
    <div class="row compact"><label>Enable stain</label><input id="stainOn" type="checkbox" checked></div>
    <div class="row"><label>Decay</label><input id="decay" type="range" min="0.90" max="0.995" step="0.001" value="0.925"><span id="decayV">0.925</span></div>
    <div class="row"><label>Strength</label><input id="strength" type="range" min="0.1" max="1" step="0.05" value="0.35"><span id="strengthV">0.35</span></div>
    <div class="row"><label>Expand (px)</label><input id="expand" type="range" min="0" max="8" step="1" value="0"><span id="expandV">0</span></div>
    <div class="row compact"><label>Stain color</label><input id="sColor" type="color" value="#223b7a"></div>

    <div class="group">Recalls</div>
    <div class="row compact"><label>Enable recall</label><input id="recallOn" type="checkbox"></div>
    <div class="row"><label>Probability</label><input id="recallProb" type="range" min="0" max="1" step="0.01" value="0.05"><span id="recallProbV">0.05</span></div>
    <div class="row"><label>Capacity</label><input id="recallCap" type="range" min="0" max="120" step="5" value="60"><span id="recallCapV">60</span></div>
    <div class="row compact"><label>Recall color</label><input id="recallColor" type="color" value="#00e7ff"></div>
    <div class="row"><label>Linger (s)</label><input id="recallLinger" type="range" min="0.2" max="3" step="0.1" value="0.6"><span id="recallLingerV">0.6</span></div>
    <div class="row"><label>Span (s)</label><input id="recallSpan" type="range" min="0" max="3" step="0.1" value="0.4"><span id="recallSpanV">0.4</span></div>
    <div class="btnRow"><button id="recallNow" class="btn">Recall now</button></div>

    <div class="group">Linger</div>
    <div class="row compact"><label>Enable linger</label><input id="hauntOn" type="checkbox"></div>
    <div class="row"><label>Persistence</label><input id="hauntPersist" type="range" min="0" max="1" step="0.01" value="0.70"><span id="hauntPersistV">0.70</span></div>
    <div class="row"><label>Reinforce radius (px)</label><input id="hauntRadius" type="range" min="10" max="60" step="1" value="30"><span id="hauntRadiusV">30</span></div>
    <div class="row"><label>Stickiness</label><input id="hauntStick" type="range" min="0" max="2" step="0.1" value="1.0"><span id="hauntStickV">1.0</span></div>
    <div class="row compact"><label>Linger color</label><input id="hauntColor" type="color" value="#4a5e8a"></div>

    <div class="group">Drawing Filter (Outlines)</div>
    <div class="row"><label>Threshold</label><input id="edgeThr" type="range" min="0" max="255" step="1" value="40"><span id="edgeThrV">40</span></div>

    <div class="row compact"><label>Ghost outline</label><input id="ghostEdgeOn" type="checkbox"></div>
    <div class="row colorop"><label>color / opacity</label><input id="ghostEdgeColor" type="color" value="#000000"><input id="ghostEdgeAlpha" type="range" min="0" max="1" step="0.05" value="0.75"><span id="ghostEdgeAlphaV">0.75</span></div>

    <div class="row compact"><label>Stain outline</label><input id="stainEdgeOn" type="checkbox"></div>
    <div class="row colorop"><label>color / opacity</label><input id="stainEdgeColor" type="color" value="#000000"><input id="stainEdgeAlpha" type="range" min="0" max="1" step="0.05" value="0.30"><span id="stainEdgeAlphaV">0.30</span></div>

    <div class="row compact"><label>Recall outline</label><input id="recallEdgeOn" type="checkbox"></div>
    <div class="row colorop"><label>color / opacity</label><input id="recallEdgeColor" type="color" value="#fbff00"><input id="recallEdgeAlpha" type="range" min="0" max="1" step="0.05" value="0.40"><span id="recallEdgeAlphaV">0.40</span></div>

    <div class="row compact"><label>Linger outline</label><input id="lingerEdgeOn" type="checkbox"></div>
    <div class="row colorop"><label>color / opacity</label><input id="lingerEdgeColor" type="color" value="#ff0000"><input id="lingerEdgeAlpha" type="range" min="0" max="1" step="0.05" value="0.75"><span id="lingerEdgeAlphaV">0.75</span></div>

    <div class="group">Export</div>
    <div class="row compact">
      <label for="matchPreview">Match preview</label>
      <input id="matchPreview" type="checkbox" checked>
      <span></span>
    </div>
    <div class="exportGrid">
      <button id="recStart" class="btn">Start Recording</button>
      <button id="recStop" class="btn" disabled>Stop &amp; Save</button>
      <button id="shot" class="btn secondary">Export PNG</button>
      <button id="exportOne" class="btn full">Export 1:1 (source)</button>
    </div>

    <div class="small" id="supportNote"></div>
    <div class="small" id="dbg">buffer: 0 | fps —</div>
  </aside>
</div>

<script>
(function(){
  /* ---------- Elements ---------- */
  const can = { stain:stain, ghost:ghost, final:final };
  const sctx = can.stain.getContext('2d');
  const gctx = can.ghost.getContext('2d');
  const fctx = can.final.getContext('2d');

  const file = document.getElementById('file');
  const webcamBtn = document.getElementById('webcam');
  const playBtn = document.getElementById('play');
  const replayBtn = document.getElementById('replay');
  const replayFloat = document.getElementById('replayFloat');
  const recStartBtn = document.getElementById('recStart');
  const recStopBtn  = document.getElementById('recStop');
  const shotBtn = document.getElementById('shot');
  const exportOneBtn = document.getElementById('exportOne');
  const matchPreview = document.getElementById('matchPreview');
  const hud = document.getElementById('hud');
  const recHUD = document.getElementById('recHUD');
  const recTime = document.getElementById('recTime');
  const dbg = document.getElementById('dbg');
  const supportNote = document.getElementById('supportNote');
  const nosrc = document.getElementById('nosrc');

  const ids = ["dt","thr","grey","preblur","gAlpha","decay","strength","expand"];
  const el  = Object.fromEntries(ids.map(id=>[id, document.getElementById(id)]));
  const out = Object.fromEntries(ids.map(id=>[id+"V", document.getElementById(id+"V")]));
  const stainOn = document.getElementById('stainOn');
  const sColor  = document.getElementById('sColor');
  const gBlend  = document.getElementById('gBlend');
  const gUseColor = document.getElementById('gUseColor');
  const gColor    = document.getElementById('gColor');

  function sync(){
    out.dtV.textContent      = (+el.dt.value).toFixed(1);
    out.thrV.textContent     = el.thr.value;
    out.greyV.textContent    = el.grey.value;
    out.preblurV.textContent = el.preblur.value;
    out.gAlphaV.textContent  = (+el.gAlpha.value).toFixed(2);
    out.decayV.textContent   = (+el.decay.value).toFixed(3);
    out.strengthV.textContent= (+el.strength.value).toFixed(2);
    out.expandV.textContent  = el.expand.value;
  }
  [...ids.map(id=>el[id]), stainOn, sColor, gBlend, gUseColor, gColor].forEach(x=>x.addEventListener('input', sync));
  sync();

  /* ---------- Source ---------- */
  const vid = document.createElement('video');
  vid.crossOrigin = "anonymous";
  vid.playsInline = true; vid.muted = true; vid.loop = true; vid.preload = "auto";

  const qs = new URLSearchParams(location.search);
  const src = qs.get('src'); if(src){ vid.src = src; }

  let mediaStream = null;
  file.addEventListener('change', e=>{
    const f = e.target.files[0];
    if(!f) return;
    stopWebcam();
    resetState();
    vid.src = URL.createObjectURL(f);
    vid.play();
  });
  playBtn.addEventListener('click', ()=> vid.paused ? vid.play() : vid.pause());
  webcamBtn.addEventListener('click', ()=> startWebcam().catch(e=>alert('Webcam failed: '+(e && e.message ? e.message : e))));

  async function startWebcam(){
    const secure = (location.protocol==='https:'||location.hostname==='localhost'||location.hostname==='127.0.0.1');
    if(!secure) throw new Error('Camera requires HTTPS or localhost.');
    if(!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia) throw new Error('getUserMedia is not available in this browser.');

    stopWebcam(); resetState();
    const tries=[
      {video:{facingMode:{ideal:'environment'},width:{ideal:1280},height:{ideal:720}},audio:false},
      {video:true,audio:false}
    ];
    let errLast=null;
    for(const constraints of tries){
      try{
        mediaStream=await navigator.mediaDevices.getUserMedia(constraints); break;
      }catch(err){errLast=err;mediaStream=null;}
    }
    if(!mediaStream){
      if(errLast && (errLast.name==='NotAllowedError'||errLast.name==='SecurityError'))
        throw new Error('Camera permission blocked. Allow access in site settings.');
      if(errLast && errLast.name==='NotFoundError')
        throw new Error('No camera device found.');
      throw errLast || new Error('Unable to access camera.');
    }
    vid.srcObject = mediaStream;
    await new Promise(res=>{
      if(vid.readyState>=1) return res();
      vid.addEventListener('loadedmetadata',res,{once:true});
    });
    try{ await vid.play(); }
    catch(_){ throw new Error('Autoplay failed. Click Play or allow autoplay.'); }
  }
  function stopWebcam(){
    if(mediaStream){
      try{mediaStream.getTracks().forEach(t=>t.stop());}catch(_){}
      mediaStream=null;
    }
    if(vid && vid.srcObject){
      try{vid.srcObject=null;}catch(_){}
    }
  }

  /* ---------- Sizing ---------- */
  const proc = document.createElement('canvas'); const pctx = proc.getContext('2d',{willReadFrequently:true});
  const maskCanvas = document.createElement('canvas'); const maskCtx = maskCanvas.getContext('2d');
  const colCanvas = document.createElement('canvas'); const colCtx = colCanvas.getContext('2d');
  const recallCanvas = document.createElement('canvas'); const recallCtx = recallCanvas.getContext('2d');
  const hauntCanvas = document.createElement('canvas'); const hauntCtx = hauntCanvas.getContext('2d');
  const tintCanvas  = document.createElement('canvas'); const tintCtx  = tintCanvas.getContext('2d');
  const edgeCanvas  = document.createElement('canvas'); const edgeCtx  = edgeCanvas.getContext('2d', { willReadFrequently:true });
  const edgeLayerCanvas = document.createElement('canvas');
  const edgeLayerCtx = edgeLayerCanvas.getContext('2d', { willReadFrequently:true });

  function fit(){
    const dpr = Math.max(1, window.devicePixelRatio||1);
    const r = can.final.getBoundingClientRect();
    const W = Math.max(2, Math.ceil(r.width*dpr));
    const H = Math.max(2, Math.ceil(r.height*dpr));
    for(const k in can){ can[k].width=W; can[k].height=H; }
    proc.width=W; proc.height=H;
    maskCanvas.width=W; maskCanvas.height=H;
    colCanvas.width=W; colCanvas.height=H;
    recallCanvas.width=W; recallCanvas.height=H;
    hauntCanvas.width=W; hauntCanvas.height=H;
    tintCanvas.width=W; tintCanvas.height=H;
    edgeCanvas.width=W; edgeCanvas.height=H;
    edgeLayerCanvas.width=W; edgeLayerCanvas.height=H;
  }
  new ResizeObserver(fit).observe(can.final); fit();

  /* ---------- Buffers ---------- */
  const buf=[]; const MAX_SEC=14;
  function pushFrame(img,t){
    buf.push({t,data:new Uint8ClampedArray(img.data),w:img.width,h:img.height});
    const cutoff=t-(MAX_SEC+2);
    while(buf.length && buf[0].t<cutoff) buf.shift();
  }
  function getPastFrame(delta){
    const target=vid.currentTime-delta;
    for(let i=buf.length-1;i>=0;i--){
      if(buf[i].t<=target) return buf[i];
    }
    return buf[0]||null;
  }

  function drawVideoContained(ctx, video, W, H, blurPx){
    ctx.save(); ctx.clearRect(0,0,W,H);
    if(blurPx>0) ctx.filter=`blur(${blurPx}px)`;
    const vw=video.videoWidth||0, vh=video.videoHeight||0;
    if(vw && vh){
      const s=Math.min(W/vw,H/vh);
      const dw=Math.round(vw*s), dh=Math.round(vh*s);
      const dx=Math.floor((W-dw)/2), dy=Math.floor((H-dh)/2);
      ctx.drawImage(video,dx,dy,dw,dh);
    }
    ctx.restore();
  }

  /* ---------- Recording helpers (MP4 ONLY) ---------- */

  const REC_MIME_MP4 = 'video/mp4;codecs=avc1.42E01E,mp4a.40.2';

  function ensureMP4SupportOrDie() {
    if (!window.MediaRecorder ||
        !MediaRecorder.isTypeSupported ||
        !MediaRecorder.isTypeSupported(REC_MIME_MP4)) {
      throw new Error('MP4 recording not supported in this browser. Use Safari.');
    }
    return REC_MIME_MP4;
  }

  function refreshSupportNote(){
    // Always MP4-only now
    supportNote.innerHTML = 'Recording format: MP4 only (Safari recommended)';
  }
  refreshSupportNote();

  let recorder=null, chunks=[], recStartTime=0, recTimer=null;

  function startRecording(){
    let mime;
    try {
      mime = ensureMP4SupportOrDie();
    } catch (err) {
      alert(err.message || err);
      return;
    }

    const stream = can.final.captureStream
      ? can.final.captureStream(30)
      : can.final.mozCaptureStream(30);

    chunks=[];
    recorder = new MediaRecorder(stream,{
      mimeType: mime,
      videoBitsPerSecond: 8_000_000
    });

    recorder.ondataavailable = e=>{
      if(e.data && e.data.size) chunks.push(e.data);
    };
    recorder.onstop = ()=>{
      const blob=new Blob(chunks,{type:mime});
      const a=document.createElement('a');
      a.download=`wind_on_wall_${Date.now()}.mp4`;
      a.href=URL.createObjectURL(blob);
      a.click();
      stopRecUI();
    };

    recorder.start(250);

    recStartTime=performance.now();
    recTimer=setInterval(()=>{
      const t=Math.floor((performance.now()-recStartTime)/1000);
      const mm=String(Math.floor(t/60)).padStart(2,'0');
      const ss=String(t%60).padStart(2,'0');
      recTime.textContent=`REC ${mm}:${ss}`;
    },250);

    recHUD.style.display='flex';
    recStartBtn.disabled=true;
    recStopBtn.disabled=false;
  }
  function stopRecording(){
    if(recorder && recorder.state==='recording'){
      recorder.stop();
    }
  }
  function stopRecUI(){
    clearInterval(recTimer); recTimer=null;
    recHUD.style.display='none';
    recStartBtn.disabled=false;
    recStopBtn.disabled=true;
  }
  recStartBtn.addEventListener('click', startRecording);
  recStopBtn.addEventListener('click',  stopRecording);

  shotBtn.addEventListener('click', ()=>{
    const a=document.createElement('a');
    a.download='still_'+Date.now()+'.png';
    a.href=can.final.toDataURL('image/png');
    a.click();
  });

  /* ---------- Replay ---------- */
  function resetState(){
    buf.length=0;
    sctx.clearRect(0,0,can.stain.width,can.stain.height);
    gctx.clearRect(0,0,can.ghost.width,can.ghost.height);
    recallBank.length=0;
    recallCtx.clearRect(0,0,recallCanvas.width,recallCanvas.height);
    activeBurst=null;
    hauntCtx.clearRect(0,0,hauntCanvas.width,hauntCanvas.height);
    tintCtx.clearRect(0,0,tintCanvas.width,tintCanvas.height);
    edgeCtx.clearRect(0,0,edgeCanvas.width,edgeCanvas.height);
  }
  function replay(){
    if(vid.srcObject){
      alert('Replay is for file/URL clips. Stop Webcam and load a clip to use Replay.');
      return;
    }
    if(!vid.currentSrc && !vid.src){
      alert('No clip loaded.');
      return;
    }
    if(recorder && recorder.state==='recording'){
      stopRecording();
    }
    try{
      vid.pause();
      resetState();
      const onSeeked=()=>{
        vid.removeEventListener('seeked',onSeeked);
        vid.play();
      };
      vid.addEventListener('seeked',onSeeked,{once:true});
      vid.currentTime=0;
    }catch(e){
      const s=vid.currentSrc || vid.src;
      if(s){
        resetState();
        vid.src=s;
        vid.play();
      }
    }
  }
  replayBtn.addEventListener('click', replay);
  replayFloat.addEventListener('click', replay);
  document.addEventListener('keydown', (e)=>{
    const t=e.target;
    if(t&&(t.tagName==='INPUT'||t.tagName==='SELECT'||t.tagName==='TEXTAREA'||t.isContentEditable)) return;
    if(e.code==='KeyR'){ e.preventDefault(); replay(); }
    else if(e.code==='Space'){ e.preventDefault(); vid.paused?vid.play():vid.pause(); }
  });

  /* ---------- Recall ---------- */
  const recallOn = document.getElementById('recallOn');
  const recallProb = document.getElementById('recallProb'); const recallProbV = document.getElementById('recallProbV');
  const recallCap  = document.getElementById('recallCap');  const recallCapV  = document.getElementById('recallCapV');
  const recallNowB = document.getElementById('recallNow');
  const recallColor= document.getElementById('recallColor');
  const recallLinger=document.getElementById('recallLinger'); const recallLingerV=document.getElementById('recallLingerV');
  const recallSpan=document.getElementById('recallSpan'); const recallSpanV=document.getElementById('recallSpanV');

  function syncRecall(){
    if(recallProbV)recallProbV.textContent=(+recallProb.value).toFixed(2);
    if(recallCapV)recallCapV.textContent=recallCap.value;
    if(recallLingerV)recallLingerV.textContent=(+recallLinger.value).toFixed(1);
    if(recallSpanV)recallSpanV.textContent=(+recallSpan.value).toFixed(1);
  }
  [recallOn,recallProb,recallCap,recallColor,recallLinger,recallSpan].forEach(x=>x&&x.addEventListener('input',syncRecall));
  syncRecall();

  const recallBank=[]; let recallBurst=0; let activeBurst=null;
  function capRecallBank(max){
    while(recallBank.length>max) recallBank.shift();
  }
  async function snapshotGhost(tNow){
    try{
      let img;
      if('createImageBitmap' in window)
        img=await createImageBitmap(can.ghost);
      else {
        const c=document.createElement('canvas');
        c.width=can.ghost.width; c.height=can.ghost.height;
        c.getContext('2d').drawImage(can.ghost,0,0);
        img=c;
      }
      recallBank.push({img,t:tNow});
      capRecallBank((+recallCap.value|0)||40);
    }catch(_){}
  }
  function startRandomBurst(){
    if(!recallBank.length) return;
    const span=Math.max(0,+recallSpan.value||0);
    const r=(Math.random()*recallBank.length)|0;
    const t0=recallBank[r].t, t1=t0+span;
    const frames=recallBank.filter(f=>f.t>=t0 && f.t<=t1).map(f=>f.img);
    activeBurst={frames:frames.length?frames:[recallBank[r].img],i:0};
  }
  if(recallNowB) recallNowB.addEventListener('click', ()=>{
    recallBurst+=1;
  });
  function drawTinted(dstCtx,src,color){
    dstCtx.globalCompositeOperation='source-over';
    dstCtx.drawImage(src,0,0);
    dstCtx.globalCompositeOperation='source-in';
    dstCtx.fillStyle=color||'#00e7ff';
    dstCtx.fillRect(0,0,recallCanvas.width,recallCanvas.height);
    dstCtx.globalCompositeOperation='source-over';
  }

  /* ---------- Linger ---------- */
  const hauntOn      = document.getElementById('hauntOn');
  const hauntPersist = document.getElementById('hauntPersist');
  const hauntRadius  = document.getElementById('hauntRadius');
  const hauntStick   = document.getElementById('hauntStick');
  const hauntColor   = document.getElementById('hauntColor');

  const hauntPersistV= document.getElementById('hauntPersistV');
  const hauntRadiusV = document.getElementById('hauntRadiusV');
  const hauntStickV  = document.getElementById('hauntStickV');

  function syncHaunt(){
    if(hauntPersistV) hauntPersistV.textContent = (+hauntPersist.value).toFixed(2);
    if(hauntRadiusV)  hauntRadiusV.textContent  = hauntRadius.value;
    if(hauntStickV)   hauntStickV.textContent   = (+hauntStick.value).toFixed(1);
  }
  [hauntOn,hauntPersist,hauntRadius,hauntStick,hauntColor].forEach(x=>x&&x.addEventListener('input',syncHaunt));
  syncHaunt();

  /* ---------- Outlines controls ---------- */
  const edgeThr      = document.getElementById('edgeThr');
  const edgeThrV     = document.getElementById('edgeThrV');

  const ghostEdgeOn   = document.getElementById('ghostEdgeOn');
  const ghostEdgeColor= document.getElementById('ghostEdgeColor');
  const ghostEdgeAlpha= document.getElementById('ghostEdgeAlpha'); const ghostEdgeAlphaV=document.getElementById('ghostEdgeAlphaV');

  const stainEdgeOn   = document.getElementById('stainEdgeOn');
  const stainEdgeColor= document.getElementById('stainEdgeColor');
  const stainEdgeAlpha= document.getElementById('stainEdgeAlpha'); const stainEdgeAlphaV=document.getElementById('stainEdgeAlphaV');

  const recallEdgeOn   = document.getElementById('recallEdgeOn');
  const recallEdgeColor= document.getElementById('recallEdgeColor');
  const recallEdgeAlpha= document.getElementById('recallEdgeAlpha'); const recallEdgeAlphaV=document.getElementById('recallEdgeAlphaV');

  const lingerEdgeOn   = document.getElementById('lingerEdgeOn');
  const lingerEdgeColor= document.getElementById('lingerEdgeColor');
  const lingerEdgeAlpha= document.getElementById('lingerEdgeAlpha'); const lingerEdgeAlphaV=document.getElementById('lingerEdgeAlphaV');

  function syncEdges(){
    if(edgeThrV) edgeThrV.textContent = edgeThr.value;
    ghostEdgeAlphaV.textContent = (+ghostEdgeAlpha.value).toFixed(2);
    stainEdgeAlphaV.textContent = (+stainEdgeAlpha.value).toFixed(2);
    recallEdgeAlphaV.textContent= (+recallEdgeAlpha.value).toFixed(2);
    lingerEdgeAlphaV.textContent= (+lingerEdgeAlpha.value).toFixed(2);
  }
  [edgeThr,ghostEdgeOn,ghostEdgeColor,ghostEdgeAlpha,stainEdgeOn,stainEdgeColor,stainEdgeAlpha,recallEdgeOn,recallEdgeColor,recallEdgeAlpha,lingerEdgeOn,lingerEdgeColor,lingerEdgeAlpha].forEach(x=>x&&x.addEventListener('input',syncEdges));
  syncEdges();

  /* ---------- Live render loop ---------- */
  let lastT=performance.now(), fpsEMA=0, suspendLive=false;
  requestAnimationFrame(function tick(now){
    requestAnimationFrame(tick);
    if(suspendLive) return;

    const W=can.final.width, H=can.final.height;
    const grey=+el.grey.value;
    fctx.clearRect(0,0,W,H);
    fctx.fillStyle=`rgb(${grey},${grey},${grey})`;
    fctx.fillRect(0,0,W,H);

    if(vid.readyState<2){
      nosrc.style.display='block';
      return;
    } else {
      nosrc.style.display='none';
    }

    drawVideoContained(pctx,vid,W,H,+el.preblur.value);
    const curr=pctx.getImageData(0,0,W,H);
    pushFrame(curr,vid.currentTime);
    const past=getPastFrame(+el.dt.value);
    if(!past) return;

    const c=curr.data, p=past.data;
    const ghostImg=gctx.createImageData(W,H);
    const gd=ghostImg.data;
    const thr=+el.thr.value;
    const mask=new Uint8ClampedArray(W*H);
    let changedCount=0;
    for(let i=0,j=0;i<c.length;i+=4,j++){
      const r=c[i], g=c[i+1], b=c[i+2];
      const pr=p[i], pg=p[i+1], pb=p[i+2];
      const lc=r*0.2126+g*0.7152+b*0.0722;
      const lp=pr*0.2126+pg*0.7152+pb*0.0722;
      const d=Math.abs(lc-lp);
      if(d>thr){
        changedCount++;
        mask[j]=255;
        if(gUseColor.checked){
          const a=Math.max(40,Math.min(255,(d-thr)*8));
          const m=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(gColor.value);
          const cr=m?parseInt(m[1],16):255,
                cg=m?parseInt(m[2],16):255,
                cb=m?parseInt(m[3],16):255;
          gd[i]=cr; gd[i+1]=cg; gd[i+2]=cb; gd[i+3]=a;
        } else {
          gd[i]=(r+(255-pr))*0.5;
          gd[i+1]=(g+(255-pg))*0.5;
          gd[i+2]=(b+(255-pb))*0.5;
          gd[i+3]=255;
        }
      } else {
        gd[i]=gd[i+1]=gd[i+2]=0;
        gd[i+3]=0;
      }
    }
    gctx.putImageData(ghostImg,0,0);

    if(stainOn.checked){
      const decay=+el.decay.value;
      sctx.globalCompositeOperation='destination-out';
      sctx.fillStyle=`rgba(0,0,0,${1-decay})`;
      sctx.fillRect(0,0,W,H);
      sctx.globalCompositeOperation='source-over';

      const mImg=maskCtx.createImageData(W,H);
      const mdat=mImg.data;
      for(let j=0,k=0;j<mask.length;j++,k+=4){
        const v=mask[j];
        mdat[k]=mdat[k+1]=mdat[k+2]=v;
        mdat[k+3]=v;
      }
      maskCtx.putImageData(mImg,0,0);

      colCtx.clearRect(0,0,W,H);
      const expand=+el.expand.value;
      if(expand>0) colCtx.filter=`blur(${expand}px)`;
      colCtx.drawImage(maskCanvas,0,0);
      colCtx.filter='none';

      colCtx.globalCompositeOperation='source-in';
      colCtx.fillStyle=sColor.value;
      colCtx.globalAlpha=+el.strength.value;
      colCtx.fillRect(0,0,W,H);
      colCtx.globalCompositeOperation='source-over';
      colCtx.globalAlpha=1;

      sctx.drawImage(colCanvas,0,0);
    }

    if(stainOn.checked){
      fctx.globalCompositeOperation='multiply';
      fctx.drawImage(can.stain,0,0);
      fctx.globalCompositeOperation='source-over';
    }
    fctx.globalAlpha=+el.gAlpha.value;
    fctx.globalCompositeOperation=gBlend.value;
    fctx.drawImage(can.ghost,0,0);
    fctx.globalAlpha=1;
    fctx.globalCompositeOperation='source-over';

    if(changedCount>0) snapshotGhost(vid.currentTime);

    {
      const lingerS=Math.max(0.2,+recallLinger.value||1.2);
      const ms=Math.max(1,now-lastT);
      const fade=1-Math.exp(-ms/(lingerS*1000));
      recallCtx.globalCompositeOperation='destination-out';
      recallCtx.fillStyle=`rgba(0,0,0,${fade})`;
      recallCtx.fillRect(0,0,recallCanvas.width,recallCanvas.height);
      recallCtx.globalCompositeOperation='source-over';
    }
    if(recallOn && recallOn.checked){
      const prob=+recallProb.value||0;
      if(Math.random()<prob && !activeBurst) startRandomBurst();
    }
    if(activeBurst && activeBurst.frames && activeBurst.frames.length){
      const color=recallColor?recallColor.value:'#00e7ff';
      drawTinted(recallCtx,activeBurst.frames[activeBurst.i],color);
      activeBurst.i++;
      if(activeBurst.i>=activeBurst.frames.length) activeBurst=null;
    }
    fctx.globalCompositeOperation='screen';
    fctx.drawImage(recallCanvas,0,0);
    fctx.globalCompositeOperation='source-over';

    if(hauntOn && hauntOn.checked){
      const p     = Math.max(0, Math.min(1, +hauntPersist.value || 0.85));
      const stick = +hauntStick.value || 1.3;
      const tint  = (hauntColor && hauntColor.value) ? hauntColor.value : '#4a5e8a';

      const decayOut = Math.max(0.001, 0.06 * (1 - p));
      hauntCtx.globalCompositeOperation = 'destination-out';
      hauntCtx.fillStyle = `rgba(0,0,0,${decayOut})`;
      hauntCtx.fillRect(0,0,hauntCanvas.width,hauntCanvas.height);

      hauntCtx.globalCompositeOperation = 'lighter';
      hauntCtx.globalAlpha = Math.min(1, 0.55 * stick);
      hauntCtx.drawImage(recallCanvas,0,0);
      hauntCtx.globalAlpha = 1;

      hauntCtx.globalCompositeOperation = 'source-over';

      tintCtx.clearRect(0,0,tintCanvas.width,tintCanvas.height);
      tintCtx.globalCompositeOperation = 'copy';
      tintCtx.drawImage(hauntCanvas,0,0);
      tintCtx.globalCompositeOperation = 'source-in';
      tintCtx.fillStyle = tint;
      tintCtx.fillRect(0,0,tintCanvas.width,tintCanvas.height);
      tintCtx.globalCompositeOperation = 'source-over';

      fctx.globalCompositeOperation = 'screen';
      fctx.globalAlpha = 0.9;
      fctx.drawImage(tintCanvas,0,0);
      fctx.globalAlpha = 1;
      fctx.globalCompositeOperation = 'source-over';
    }

    if (edgeThr) edgeThrV.textContent = edgeThr.value;
    if (document.getElementById('edgeThr')) {
      const TH = (+edgeThr.value | 0) || 40;
      const TL = Math.max(0, Math.floor(TH * 0.5));

      function rgbaFrom(hex, a01){
        const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex||'#000000');
        return [
          parseInt(m[1],16),
          parseInt(m[2],16),
          parseInt(m[3],16),
          Math.max(0,Math.min(1,a01||1))
        ];
      }
      function drawOutlineFrom(srcCanvas, colorHex, alpha01){
        const W = srcCanvas.width, H = srcCanvas.height;
        if (!W || !H) return;
        const sctx2 = srcCanvas.getContext('2d');
        const img  = sctx2.getImageData(0,0,W,H);
        const d    = img.data;

        const L = new Uint8ClampedArray(W*H);
        for (let i=0,j=0;i<d.length;i+=4,++j){
          const lum = d[i]*0.2126 + d[i+1]*0.7152 + d[i+2]*0.0722;
          const a   = d[i+3];
          L[j] = Math.max(lum, a);
        }

        const E = new Uint8ClampedArray(W*H);
        for (let y=1;y<H-1;y++){
          let idx=y*W+1;
          for (let x=1;x<W-1;x++,idx++){
            const a=L[idx-W-1], b=L[idx-W],   c=L[idx-W+1];
            const d0=L[idx-1],              f=L[idx+1];
            const g=L[idx+W-1], h=L[idx+W], i=L[idx+W+1];
            const gx = -a -2*b -c + g +2*h + i;
            const gy = -a -2*d0 -g + c +2*f + i;
            const mag = Math.abs(gx) + Math.abs(gy);
            let aa;
            if (mag >= TH) aa = 255;
            else if (mag <= TL) aa = 0;
            else aa = Math.round((mag - TL)/(TH - TL)*255);
            E[idx] = aa;
          }
        }
        for (let k=0,j=0;k<d.length;k+=4,++j){
          E[j] = Math.round(E[j] * (d[k+3]/255));
        }

        edgeLayerCtx.clearRect(0,0,edgeLayerCanvas.width,edgeLayerCanvas.height);
        const [r,g,b,a01Out] = rgbaFrom(colorHex, alpha01);
        const mask = edgeLayerCtx.createImageData(W,H);
        const md = mask.data;
        for (let j=0,p=0;j<E.length;j++,p+=4){
          const a = E[j];
          if (!a){
            md[p]=md[p+1]=md[p+2]=md[p+3]=0;
            continue;
          }
          md[p]=r; md[p+1]=g; md[p+2]=b;
          md[p+3]=Math.min(255, Math.round(a*a01Out));
        }
        edgeLayerCtx.putImageData(mask,0,0);

        edgeCtx.globalCompositeOperation='source-over';
        edgeCtx.drawImage(edgeLayerCanvas,0,0);
      }

      edgeCtx.clearRect(0,0,edgeCanvas.width,edgeCanvas.height);
      if (ghostEdgeOn && ghostEdgeOn.checked)
        drawOutlineFrom(can.ghost,    ghostEdgeColor.value,  +ghostEdgeAlpha.value||0.8);
      if (stainEdgeOn && stainEdgeOn.checked)
        drawOutlineFrom(can.stain,    stainEdgeColor.value,  +stainEdgeAlpha.value||0.7);
      if (recallEdgeOn && recallEdgeOn.checked)
        drawOutlineFrom(recallCanvas, recallEdgeColor.value, +recallEdgeAlpha.value||0.7);
      if (lingerEdgeOn && lingerEdgeOn.checked)
        drawOutlineFrom(hauntCanvas,  lingerEdgeColor.value, +lingerEdgeAlpha.value||0.8);

      fctx.globalCompositeOperation='source-over';
      fctx.drawImage(edgeCanvas,0,0);
    }

    const dt=now-lastT; lastT=now;
    const inst=dt>0?1000/dt:0;
    fpsEMA=fpsEMA?fpsEMA*0.9+inst*0.1:inst;

    dbg.textContent=`buffer: ${buf.length} | fps ~ ${fpsEMA.toFixed(1)} | MP4-only`;
  });

  vid.addEventListener('loadeddata', ()=>{
    vid.play().catch(()=>{});
  });

  /* ---------- Export 1:1 (MP4-only, pause live loop) ---------- */
  exportOneBtn.addEventListener('click', exportSourceOnce);

  async function exportSourceOnce(){
    if(vid.srcObject){
      alert('1:1 export is for file/URL clips, not webcam.');
      return;
    }
    if(!(vid.currentSrc || vid.src)){
      alert('Load a clip first.');
      return;
    }

    if(vid.readyState < 1){
      await new Promise(res => vid.addEventListener('loadedmetadata', res, {once:true}));
    }

    const vw = vid.videoWidth|0;
    const vh = vid.videoHeight|0;
    if(!vw || !vh){
      alert('Video metadata unavailable.');
      return;
    }

    // Enforce MP4-only
    let mime;
    try {
      mime = ensureMP4SupportOrDie();
    } catch (err) {
      alert(err.message || err);
      return;
    }

    // Stop live loop during export
    suspendLive = true;

    exportOneBtn.disabled = true;
    recStartBtn.disabled = true;

    const prev = {
      loop: vid.loop,
      rate: vid.playbackRate,
      paused: vid.paused,
      t: vid.currentTime
    };

    vid.pause();
    vid.loop = false;
    vid.playbackRate = 1.0;

    // Store original sizes
    const restoreSizes = {
      finW: can.final.width, finH: can.final.height,
      stainW: can.stain.width, stainH: can.stain.height,
      ghostW: can.ghost.width, ghostH: can.ghost.height,
      procW: proc.width, procH: proc.height,
      maskW: maskCanvas.width, maskH: maskCanvas.height,
      colW: colCanvas.width, colH: colCanvas.height,
      recallW: recallCanvas.width, recallH: recallCanvas.height,
      hauntW: hauntCanvas.width, hauntH: hauntCanvas.height,
      tintW: tintCanvas.width, tintH: tintCanvas.height,
      edgeW: edgeCanvas.width, edgeH: edgeCanvas.height,
      edgeLayerW: edgeLayerCanvas.width, edgeLayerH: edgeLayerCanvas.height
    };

    // Resize all canvases to video native resolution
    function resizeAllToNative() {
      can.final.width = vw;   can.final.height = vh;
      can.stain.width = vw;   can.stain.height = vh;
      can.ghost.width = vw;   can.ghost.height = vh;

      proc.width = vw;        proc.height = vh;
      maskCanvas.width = vw;  maskCanvas.height = vh;
      colCanvas.width = vw;   colCanvas.height  = vh;

      recallCanvas.width = vw;  recallCanvas.height = vh;
      hauntCanvas.width  = vw;  hauntCanvas.height  = vh;
      tintCanvas.width   = vw;  tintCanvas.height   = vh;

      edgeCanvas.width      = vw;  edgeCanvas.height      = vh;
      edgeLayerCanvas.width = vw;  edgeLayerCanvas.height = vh;

      resetState(); // Clear all buffers
    }
    resizeAllToNative();

    const outCanvas = document.createElement('canvas');
    outCanvas.width  = vw;
    outCanvas.height = vh;
    const octx = outCanvas.getContext('2d');

    const expChunks = [];
    const stream = outCanvas.captureStream(30); // Explicit 30 FPS

    const expRecorder = new MediaRecorder(stream, {
      mimeType: mime,
      videoBitsPerSecond: 8000000 // Reduced from 20M to 8M for better compatibility
    });

    const recDone = new Promise(resolve => {
      expRecorder.ondataavailable = e => {
        if(e.data && e.data.size) expChunks.push(e.data);
      };
      expRecorder.onstop = resolve;
    });

    // Safety timeout
    const safetyMs = (isFinite(vid.duration) ? vid.duration : 60) * 1000 + 5000;
    const safetyTimer = setTimeout(() => {
      console.log('Safety timeout reached');
      finalizeExport();
    }, safetyMs);

    // Start recording
    expRecorder.start(1000); // Collect data every second for better reliability

    // Seek to beginning
    await new Promise(resolve => {
      const onSeeked = () => {
        vid.removeEventListener('seeked', onSeeked);
        resolve();
      };
      vid.addEventListener('seeked', onSeeked, {once: true});
      vid.currentTime = 0;
    });

    let lastFrameTime = 0;
    const frameInterval = 1000 / 30; // Target 30 FPS

    function processFrame() {
      const now = performance.now();
      if (now - lastFrameTime < frameInterval) {
        return; // Skip frame to maintain consistent frame rate
      }
      lastFrameTime = now;

      // Process video frame
      drawVideoContained(pctx, vid, vw, vh, +el.preblur.value);
      const {changedCount} = buildGhostAndStain(vw, vh, vid.currentTime);

      // Process recalls and other effects
      fadeRecallLayer(frameInterval);
      maybeDoRecall(changedCount, vid.currentTime);
      drawHauntAndCompositeFinal(vw, vh);

      // Draw to output canvas for recording
      octx.drawImage(can.final, 0, 0, vw, vh);
    }

    let animationId;
    function renderLoop() {
      if (vid.ended || vid.paused) {
        cancelAnimationFrame(animationId);
        finalizeExport();
        return;
      }
      processFrame();
      animationId = requestAnimationFrame(renderLoop);
    }

    // Start playback and processing
    try {
      await vid.play();
      lastFrameTime = performance.now();
      renderLoop();
    } catch (error) {
      console.error('Playback failed:', error);
      finalizeExport();
    }

    async function finalizeExport() {
      clearTimeout(safetyTimer);
      cancelAnimationFrame(animationId);

      // Wait a bit to ensure all frames are processed
      await new Promise(resolve => setTimeout(resolve, 500));

      if (expRecorder.state === 'recording') {
        expRecorder.stop();
      }

      // Wait for recording to fully stop
      await recDone;

      // Restore original canvas sizes
      can.final.width  = restoreSizes.finW;   can.final.height  = restoreSizes.finH;
      can.stain.width  = restoreSizes.stainW; can.stain.height  = restoreSizes.stainH;
      can.ghost.width  = restoreSizes.ghostW; can.ghost.height  = restoreSizes.ghostH;

      proc.width       = restoreSizes.procW;  proc.height       = restoreSizes.procH;
      maskCanvas.width = restoreSizes.maskW;  maskCanvas.height = restoreSizes.maskH;
      colCanvas.width  = restoreSizes.colW;   colCanvas.height  = restoreSizes.colH;

      recallCanvas.width = restoreSizes.recallW; recallCanvas.height = restoreSizes.recallH;
      hauntCanvas.width  = restoreSizes.hauntW;  hauntCanvas.height  = restoreSizes.hauntH;
      tintCanvas.width   = restoreSizes.tintW;   tintCanvas.height   = restoreSizes.tintH;

      edgeCanvas.width      = restoreSizes.edgeW;      edgeCanvas.height      = restoreSizes.edgeH;
      edgeLayerCanvas.width = restoreSizes.edgeLayerW; edgeLayerCanvas.height = restoreSizes.edgeLayerH;

      // Restore video state
      vid.loop = prev.loop;
      vid.playbackRate = prev.rate;
      try { vid.currentTime = prev.t; } catch(_) {}
      if (!prev.paused) {
        vid.play().catch(() => {});
      }

      exportOneBtn.disabled = false;
      recStartBtn.disabled  = false;
      suspendLive = false;

      // Create and download the file
      if (expChunks.length > 0) {
        const blob = new Blob(expChunks, {type: mime});
        const a = document.createElement('a');
        a.download = `wind_on_wall_1x_${vw}x${vh}_${Date.now()}.mp4`;
        a.href = URL.createObjectURL(blob);
        a.click();
        
        // Clean up URL
        setTimeout(() => URL.revokeObjectURL(a.href), 1000);
      } else {
        alert('Export failed: No video data recorded');
      }
    }

    // Set up end detection
    vid.addEventListener('ended', finalizeExport, {once: true});
  }

  // Helper functions for export processing
  function drawVideoContainedExact(ctx, video, W, H, blurPx){
    ctx.save();
    ctx.clearRect(0,0,W,H);
    if(blurPx>0) ctx.filter=`blur(${blurPx}px)`;

    const vw0 = video.videoWidth  || 0;
    const vh0 = video.videoHeight || 0;
    if(vw0 && vh0){
      const s = Math.min(W/vw0, H/vh0);
      const dw = Math.round(vw0*s), dh = Math.round(vh0*s);
      const dx = Math.floor((W-dw)/2), dy = Math.floor((H-dh)/2);
      ctx.drawImage(video, dx, dy, dw, dh);
    }
    ctx.restore();
  }

  function buildGhostAndStain(W,H,tNow){
    const currImg = pctx.getImageData(0,0,W,H);
    pushFrame(currImg, tNow);
    const past = getPastFrame(+el.dt.value);
    gctx.clearRect(0,0,W,H);

    if(!past){
      return {changedCount:0};
    }

    const c = currImg.data;
    const p = past.data;
    const ghostImg = gctx.createImageData(W,H);
    const gd = ghostImg.data;
    const thr = +el.thr.value;
    const maskArr = new Uint8ClampedArray(W*H);

    let changedCount=0;
    for(let i=0,j=0;i<c.length;i+=4,j++){
      const r=c[i],g=c[i+1],b=c[i+2];
      const pr=p[i],pg=p[i+1],pb=p[i+2];
      const lc=r*0.2126+g*0.7152+b*0.0722;
      const lp=pr*0.2126+pg*0.7152+pb*0.0722;
      const d=Math.abs(lc-lp);

      if(d>thr){
        changedCount++;
        maskArr[j]=255;
        if(gUseColor.checked){
          const m=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(gColor.value);
          const cr=m?parseInt(m[1],16):255;
          const cg=m?parseInt(m[2],16):255;
          const cb=m?parseInt(m[3],16):255;
          const a=Math.max(40,Math.min(255,(d-thr)*8));
          gd[i]=cr; gd[i+1]=cg; gd[i+2]=cb; gd[i+3]=a;
        } else {
          gd[i]=(r+(255-pr))*0.5;
          gd[i+1]=(g+(255-pg))*0.5;
          gd[i+2]=(b+(255-pb))*0.5;
          gd[i+3]=255;
        }
      } else {
        gd[i]=gd[i+1]=gd[i+2]=0;
        gd[i+3]=0;
      }
    }
    gctx.putImageData(ghostImg,0,0);

    if(stainOn.checked){
      const decay=+el.decay.value;
      sctx.globalCompositeOperation='destination-out';
      sctx.fillStyle=`rgba(0,0,0,${1-decay})`;
      sctx.fillRect(0,0,W,H);
      sctx.globalCompositeOperation='source-over';

      const mImg = maskCtx.createImageData(W,H);
      const mdat = mImg.data;
      for(let j=0,k=0;j<maskArr.length;j++,k+=4){
        const v=maskArr[j];
        mdat[k]=mdat[k+1]=mdat[k+2]=v;
        mdat[k+3]=v;
      }
      maskCtx.putImageData(mImg,0,0);

      colCtx.clearRect(0,0,W,H);
      const expand=+el.expand.value;
      if(expand>0) colCtx.filter=`blur(${expand}px)`;
      colCtx.drawImage(maskCanvas,0,0);
      colCtx.filter='none';

      colCtx.globalCompositeOperation='source-in';
      colCtx.fillStyle=sColor.value;
      colCtx.globalAlpha=+el.strength.value;
      colCtx.fillRect(0,0,W,H);

      colCtx.globalCompositeOperation='source-over';
      colCtx.globalAlpha=1;
      sctx.drawImage(colCanvas,0,0);
    }

    return {changedCount};
  }

  function fadeRecallLayer(dtMs){
    const lingerS = Math.max(0.2, +recallLinger.value || 1.2);
    const fade    = 1 - Math.exp(-(dtMs)/(lingerS*1000));
    recallCtx.globalCompositeOperation='destination-out';
    recallCtx.fillStyle=`rgba(0,0,0,${fade})`;
    recallCtx.fillRect(0,0,recallCanvas.width,recallCanvas.height);
    recallCtx.globalCompositeOperation='source-over';
  }

  async function maybeDoRecall(changedNow, tNow){
    if(changedNow>0){
      try {
        let img;
        if('createImageBitmap' in window){
          img = await createImageBitmap(can.ghost);
        } else {
          const c2=document.createElement('canvas');
          c2.width=can.ghost.width; c2.height=can.ghost.height;
          c2.getContext('2d').drawImage(can.ghost,0,0);
          img=c2;
        }
        recallBank.push({img, t:tNow});
        capRecallBank((+recallCap.value|0) || 40);
      } catch(_){}
    }

    if(recallOn && recallOn.checked){
      const prob = +recallProb.value || 0;
      if(Math.random() < prob && !activeBurst){
        startRandomBurst();
      }
    }

    if(activeBurst && activeBurst.frames && activeBurst.frames.length){
      const color = recallColor ? recallColor.value : '#00e7ff';
      drawTinted(recallCtx, activeBurst.frames[activeBurst.i], color);
      activeBurst.i++;
      if(activeBurst.i >= activeBurst.frames.length){
        activeBurst = null;
      }
    }
  }

  function drawHauntAndCompositeFinal(W,H){
    fctx.clearRect(0,0,W,H);

    const grey = +el.grey.value;
    fctx.fillStyle=`rgb(${grey},${grey},${grey})`;
    fctx.fillRect(0,0,W,H);

    if(stainOn.checked){
      fctx.globalCompositeOperation='multiply';
      fctx.drawImage(can.stain,0,0);
      fctx.globalCompositeOperation='source-over';
    }

    fctx.globalAlpha = +el.gAlpha.value;
    fctx.globalCompositeOperation = gBlend.value;
    fctx.drawImage(can.ghost,0,0);
    fctx.globalAlpha = 1;
    fctx.globalCompositeOperation='source-over';

    fctx.globalCompositeOperation='screen';
    fctx.drawImage(recallCanvas,0,0);
    fctx.globalCompositeOperation='source-over';

    if(hauntOn && hauntOn.checked){
      const p     = Math.max(0, Math.min(1, +hauntPersist.value || 0.85));
      const stick = +hauntStick.value || 1.3;
      const tint  = (hauntColor && hauntColor.value) ? hauntColor.value : '#4a5e8a';

      const decayOut = Math.max(0.001, 0.06 * (1 - p));
      hauntCtx.globalCompositeOperation='destination-out';
      hauntCtx.fillStyle=`rgba(0,0,0,${decayOut})`;
      hauntCtx.fillRect(0,0,hauntCanvas.width,hauntCanvas.height);

      hauntCtx.globalCompositeOperation='lighter';
      hauntCtx.globalAlpha = Math.min(1, 0.55 * stick);
      hauntCtx.drawImage(recallCanvas,0,0);
      hauntCtx.globalAlpha = 1;
      hauntCtx.globalCompositeOperation='source-over';

      tintCtx.clearRect(0,0,tintCanvas.width,tintCanvas.height);
      tintCtx.globalCompositeOperation='copy';
      tintCtx.drawImage(hauntCanvas,0,0);
      tintCtx.globalCompositeOperation='source-in';
      tintCtx.fillStyle = tint;
      tintCtx.fillRect(0,0,tintCanvas.width,tintCanvas.height);
      tintCtx.globalCompositeOperation='source-over';

      fctx.globalCompositeOperation='screen';
      fctx.globalAlpha=0.9;
      fctx.drawImage(tintCanvas,0,0);
      fctx.globalAlpha=1;
      fctx.globalCompositeOperation='source-over';
    }

    edgeCtx.clearRect(0,0,edgeCanvas.width,edgeCanvas.height);

    const TH = (+edgeThr.value | 0) || 40;
    const TL = Math.max(0, Math.floor(TH*0.5));

    function drawOutlineFrom(srcCanvas, colorHex, alpha01){
      const W = srcCanvas.width, H = srcCanvas.height;
      if(!W||!H) return;

      const sctx2 = srcCanvas.getContext('2d');
      const img  = sctx2.getImageData(0,0,W,H);
      const d    = img.data;

      const L = new Uint8ClampedArray(W*H);
      for(let i=0,j=0;i<d.length;i+=4,++j){
        const lum = d[i]*0.2126 + d[i+1]*0.7152 + d[i+2]*0.0722;
        const a   = d[i+3];
        L[j] = Math.max(lum, a);
      }

      const E = new Uint8ClampedArray(W*H);
      for(let y=1;y<H-1;y++){
        let idx=y*W+1;
        for(let x=1;x<W-1;x++,idx++){
          const a=L[idx-W-1], b=L[idx-W],   c=L[idx-W+1];
          const d0=L[idx-1],              f=L[idx+1];
          const g=L[idx+W-1], h=L[idx+W], i=L[idx+W+1];
          const gx = -a -2*b -c + g +2*h + i;
          const gy = -a -2*d0 -g + c +2*f + i;
          const mag = Math.abs(gx)+Math.abs(gy);

          let aa;
          if(mag>=TH) aa=255;
          else if(mag<=TL) aa=0;
          else aa=Math.round((mag-TL)/(TH-TL)*255);

          E[idx]=aa;
        }
      }

      for(let k=0,j=0;k<d.length;k+=4,++j){
        E[j] = Math.round(E[j] * (d[k+3]/255));
      }

      edgeLayerCtx.clearRect(0,0,edgeLayerCanvas.width,edgeLayerCanvas.height);
      const [r,g,b,a01Out] = rgbaFrom(colorHex, alpha01);
      const mask = edgeLayerCtx.createImageData(W,H);
      const md   = mask.data;
      for(let j=0,p=0;j<E.length;j++,p+=4){
        const a = E[j];
        if(!a){
          md[p]=md[p+1]=md[p+2]=md[p+3]=0;
          continue;
        }
        md[p]   = r;
        md[p+1] = g;
        md[p+2] = b;
        md[p+3] = Math.min(255, Math.round(a*a01Out));
      }
      edgeLayerCtx.putImageData(mask,0,0);

      edgeCtx.globalCompositeOperation='source-over';
      edgeCtx.drawImage(edgeLayerCanvas,0,0);
    }

    if(ghostEdgeOn && ghostEdgeOn.checked)
      drawOutlineFrom(can.ghost, ghostEdgeColor.value, +ghostEdgeAlpha.value||0.8);
    if(stainEdgeOn && stainEdgeOn.checked)
      drawOutlineFrom(can.stain, stainEdgeColor.value, +stainEdgeAlpha.value||0.7);
    if(recallEdgeOn && recallEdgeOn.checked)
      drawOutlineFrom(recallCanvas, recallEdgeColor.value, +recallEdgeAlpha.value||0.7);
    if(lingerEdgeOn && lingerEdgeOn.checked)
      drawOutlineFrom(hauntCanvas, lingerEdgeColor.value, +lingerEdgeAlpha.value||0.8);

    fctx.drawImage(edgeCanvas,0,0);
  }

  function rgbaFrom(hex, a01){
    const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex||'#000000');
    return [
      parseInt(m[1],16),
      parseInt(m[2],16),
      parseInt(m[3],16),
      Math.max(0,Math.min(1,a01||1))
    ];
  }
})();
</script>

<script>
(function(){
  function paint(r){
    var min=r.min?+r.min:0, max=r.max?+r.max:100;
    var val=isNaN(+r.value)?min:+r.value;
    var p=((val-min)/(max-min))*100;
    r.style.setProperty('--p', p+'%');
  }
  var ranges=document.querySelectorAll('input[type="range"]');
  ranges.forEach(function(r){
    paint(r);
    r.addEventListener('input', function(){ paint(r); });
  });
})();
</script>
</body>
</html>
